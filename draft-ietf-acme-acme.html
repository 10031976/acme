<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Automatic Certificate Management Environment (ACME)</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>


  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Deployment Model and Operator Experience"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Terminology"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Protocol Overview"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Message Transport"/>
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 HTTPS Requests"/>
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Request Authentication"/>
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Equivalence of JWKs"/>
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 Request URI Integrity"/>
<link href="#rfc.section.5.4.1" rel="Chapter" title="5.4.1 &#x201C;url&#x201D; (URL) JWS header parameter"/>
<link href="#rfc.section.5.5" rel="Chapter" title="5.5 Replay protection"/>
<link href="#rfc.section.5.5.1" rel="Chapter" title="5.5.1 Replay-Nonce"/>
<link href="#rfc.section.5.5.2" rel="Chapter" title="5.5.2 &#x201C;nonce&#x201D; (Nonce) JWS header parameter"/>
<link href="#rfc.section.5.6" rel="Chapter" title="5.6 Rate limits"/>
<link href="#rfc.section.5.7" rel="Chapter" title="5.7 Errors"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Certificate Management"/>
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Resources"/>
<link href="#rfc.section.6.1.1" rel="Chapter" title="6.1.1 Directory"/>
<link href="#rfc.section.6.1.2" rel="Chapter" title="6.1.2 Account Objects"/>
<link href="#rfc.section.6.1.3" rel="Chapter" title="6.1.3 Order Objects"/>
<link href="#rfc.section.6.1.4" rel="Chapter" title="6.1.4 Authorization Objects"/>
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Getting a Nonce"/>
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Account Creation"/>
<link href="#rfc.section.6.3.1" rel="Chapter" title="6.3.1 Changes of Terms of Service"/>
<link href="#rfc.section.6.3.2" rel="Chapter" title="6.3.2 External Account Binding"/>
<link href="#rfc.section.6.3.3" rel="Chapter" title="6.3.3 Account Key Roll-over"/>
<link href="#rfc.section.6.3.4" rel="Chapter" title="6.3.4 Account deactivation"/>
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 Applying for Certificate Issuance"/>
<link href="#rfc.section.6.4.1" rel="Chapter" title="6.4.1 Pre-Authorization"/>
<link href="#rfc.section.6.4.2" rel="Chapter" title="6.4.2 Downloading the Certificate"/>
<link href="#rfc.section.6.5" rel="Chapter" title="6.5 Identifier Authorization"/>
<link href="#rfc.section.6.5.1" rel="Chapter" title="6.5.1 Responding to Challenges"/>
<link href="#rfc.section.6.5.2" rel="Chapter" title="6.5.2 Deactivating an Authorization"/>
<link href="#rfc.section.6.6" rel="Chapter" title="6.6 Certificate Revocation"/>
<link href="#rfc.section.7" rel="Chapter" title="7 Identifier Validation Challenges"/>
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Key Authorizations"/>
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 HTTP"/>
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 TLS with Server Name Indication (TLS SNI)"/>
<link href="#rfc.section.7.4" rel="Chapter" title="7.4 DNS"/>
<link href="#rfc.section.7.5" rel="Chapter" title="7.5 Out-of-Band"/>
<link href="#rfc.section.8" rel="Chapter" title="8 IANA Considerations"/>
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Well-Known URI for the HTTP Challenge"/>
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 Replay-Nonce HTTP Header"/>
<link href="#rfc.section.8.3" rel="Chapter" title="8.3 &#x201C;url&#x201D; JWS Header Parameter"/>
<link href="#rfc.section.8.4" rel="Chapter" title="8.4 &#x201C;nonce&#x201D; JWS Header Parameter"/>
<link href="#rfc.section.8.5" rel="Chapter" title="8.5 URN Sub-namespace for ACME (urn:ietf:params:acme)"/>
<link href="#rfc.section.8.6" rel="Chapter" title="8.6 New Registries"/>
<link href="#rfc.section.8.6.1" rel="Chapter" title="8.6.1 Fields in Account Objects"/>
<link href="#rfc.section.8.6.2" rel="Chapter" title="8.6.2 Fields in Order Objects"/>
<link href="#rfc.section.8.6.3" rel="Chapter" title="8.6.3 Error Types"/>
<link href="#rfc.section.8.6.4" rel="Chapter" title="8.6.4 Resource Types"/>
<link href="#rfc.section.8.6.5" rel="Chapter" title="8.6.5 Identifier Types"/>
<link href="#rfc.section.8.6.6" rel="Chapter" title="8.6.6 Challenge Types"/>
<link href="#rfc.section.9" rel="Chapter" title="9 Security Considerations"/>
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 Threat model"/>
<link href="#rfc.section.9.2" rel="Chapter" title="9.2 Integrity of Authorizations"/>
<link href="#rfc.section.9.3" rel="Chapter" title="9.3 Denial-of-Service Considerations"/>
<link href="#rfc.section.9.4" rel="Chapter" title="9.4 Server-Side Request Forgery"/>
<link href="#rfc.section.9.5" rel="Chapter" title="9.5 CA Policy Considerations"/>
<link href="#rfc.section.10" rel="Chapter" title="10 Operational Considerations"/>
<link href="#rfc.section.10.1" rel="Chapter" title="10.1 DNS security"/>
<link href="#rfc.section.10.2" rel="Chapter" title="10.2 Default Virtual Hosts"/>
<link href="#rfc.section.11" rel="Chapter" title="11 Acknowledgements"/>
<link href="#rfc.references" rel="Chapter" title="12 References"/>
<link href="#rfc.references.1" rel="Chapter" title="12.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="12.2 Informative References"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.2 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Barnes, R., Hoffman-Andrews, J., and J. Kasten" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-acme-acme-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2017-2-17" />
  <meta name="dct.abstract" content="Certificates in PKI using X.509 (PKIX) are used for a number of purposes, the most significant of which is the authentication of domain names.  Thus, certificate authorities in the Web PKI are trusted to verify that an applicant for a certificate legitimately represents the domain name(s) in the certificate.  Today, this verification is done through a collection of ad hoc mechanisms.  This document describes a protocol that a certification authority (CA) and an applicant can use to automate the process of verification and certificate issuance.  The protocol also provides facilities for other certificate management functions, such as certificate revocation." />
  <meta name="description" content="Certificates in PKI using X.509 (PKIX) are used for a number of purposes, the most significant of which is the authentication of domain names.  Thus, certificate authorities in the Web PKI are trusted to verify that an applicant for a certificate legitimately represents the domain name(s) in the certificate.  Today, this verification is done through a collection of ad hoc mechanisms.  This document describes a protocol that a certification authority (CA) and an applicant can use to automate the process of verification and certificate issuance.  The protocol also provides facilities for other certificate management functions, such as certificate revocation." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">Network Working Group</td>
  <td class="right">R. Barnes</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">Mozilla</td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">J. Hoffman-Andrews</td>
</tr>
<tr>
  <td class="left">Expires: August 21, 2017</td>
  <td class="right">EFF</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">J. Kasten</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">University of Michigan</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">February 17, 2017</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Automatic Certificate Management Environment (ACME)<br />
  <span class="filename">draft-ietf-acme-acme-latest</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>Certificates in PKI using X.509 (PKIX) are used for a number of purposes, the most significant of which is the authentication of domain names.  Thus, certificate authorities in the Web PKI are trusted to verify that an applicant for a certificate legitimately represents the domain name(s) in the certificate.  Today, this verification is done through a collection of ad hoc mechanisms.  This document describes a protocol that a certification authority (CA) and an applicant can use to automate the process of verification and certificate issuance.  The protocol also provides facilities for other certificate management functions, such as certificate revocation.</p>
<p>DISCLAIMER: This is a work in progress draft of ACME and has not yet had a thorough security analysis.</p>
<p>RFC EDITOR: PLEASE REMOVE THE FOLLOWING PARAGRAPH: The source for this draft is maintained in GitHub. Suggested changes should be submitted as pull requests at <a href="https://github.com/ietf-wg-acme/acme">https://github.com/ietf-wg-acme/acme</a>. Instructions are on that page as well.  Editorial changes can be managed in GitHub, but any substantive change should be discussed on the ACME mailing list (acme@ietf.org).</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on August 21, 2017.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2017 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<li>2.   <a href="#rfc.section.2">Deployment Model and Operator Experience</a></li>
<li>3.   <a href="#rfc.section.3">Terminology</a></li>
<li>4.   <a href="#rfc.section.4">Protocol Overview</a></li>
<li>5.   <a href="#rfc.section.5">Message Transport</a></li>
<ul><li>5.1.   <a href="#rfc.section.5.1">HTTPS Requests</a></li>
<li>5.2.   <a href="#rfc.section.5.2">Request Authentication</a></li>
<li>5.3.   <a href="#rfc.section.5.3">Equivalence of JWKs</a></li>
<li>5.4.   <a href="#rfc.section.5.4">Request URI Integrity</a></li>
<ul><li>5.4.1.   <a href="#rfc.section.5.4.1">&#8220;url&#8221; (URL) JWS header parameter</a></li>
</ul><li>5.5.   <a href="#rfc.section.5.5">Replay protection</a></li>
<ul><li>5.5.1.   <a href="#rfc.section.5.5.1">Replay-Nonce</a></li>
<li>5.5.2.   <a href="#rfc.section.5.5.2">&#8220;nonce&#8221; (Nonce) JWS header parameter</a></li>
</ul><li>5.6.   <a href="#rfc.section.5.6">Rate limits</a></li>
<li>5.7.   <a href="#rfc.section.5.7">Errors</a></li>
</ul><li>6.   <a href="#rfc.section.6">Certificate Management</a></li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Resources</a></li>
<ul><li>6.1.1.   <a href="#rfc.section.6.1.1">Directory</a></li>
<li>6.1.2.   <a href="#rfc.section.6.1.2">Account Objects</a></li>
<li>6.1.3.   <a href="#rfc.section.6.1.3">Order Objects</a></li>
<li>6.1.4.   <a href="#rfc.section.6.1.4">Authorization Objects</a></li>
</ul><li>6.2.   <a href="#rfc.section.6.2">Getting a Nonce</a></li>
<li>6.3.   <a href="#rfc.section.6.3">Account Creation</a></li>
<ul><li>6.3.1.   <a href="#rfc.section.6.3.1">Changes of Terms of Service</a></li>
<li>6.3.2.   <a href="#rfc.section.6.3.2">External Account Binding</a></li>
<li>6.3.3.   <a href="#rfc.section.6.3.3">Account Key Roll-over</a></li>
<li>6.3.4.   <a href="#rfc.section.6.3.4">Account deactivation</a></li>
</ul><li>6.4.   <a href="#rfc.section.6.4">Applying for Certificate Issuance</a></li>
<ul><li>6.4.1.   <a href="#rfc.section.6.4.1">Pre-Authorization</a></li>
<li>6.4.2.   <a href="#rfc.section.6.4.2">Downloading the Certificate</a></li>
</ul><li>6.5.   <a href="#rfc.section.6.5">Identifier Authorization</a></li>
<ul><li>6.5.1.   <a href="#rfc.section.6.5.1">Responding to Challenges</a></li>
<li>6.5.2.   <a href="#rfc.section.6.5.2">Deactivating an Authorization</a></li>
</ul><li>6.6.   <a href="#rfc.section.6.6">Certificate Revocation</a></li>
</ul><li>7.   <a href="#rfc.section.7">Identifier Validation Challenges</a></li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Key Authorizations</a></li>
<li>7.2.   <a href="#rfc.section.7.2">HTTP</a></li>
<li>7.3.   <a href="#rfc.section.7.3">TLS with Server Name Indication (TLS SNI)</a></li>
<li>7.4.   <a href="#rfc.section.7.4">DNS</a></li>
<li>7.5.   <a href="#rfc.section.7.5">Out-of-Band</a></li>
</ul><li>8.   <a href="#rfc.section.8">IANA Considerations</a></li>
<ul><li>8.1.   <a href="#rfc.section.8.1">Well-Known URI for the HTTP Challenge</a></li>
<li>8.2.   <a href="#rfc.section.8.2">Replay-Nonce HTTP Header</a></li>
<li>8.3.   <a href="#rfc.section.8.3">&#8220;url&#8221; JWS Header Parameter</a></li>
<li>8.4.   <a href="#rfc.section.8.4">&#8220;nonce&#8221; JWS Header Parameter</a></li>
<li>8.5.   <a href="#rfc.section.8.5">URN Sub-namespace for ACME (urn:ietf:params:acme)</a></li>
<li>8.6.   <a href="#rfc.section.8.6">New Registries</a></li>
<ul><li>8.6.1.   <a href="#rfc.section.8.6.1">Fields in Account Objects</a></li>
<li>8.6.2.   <a href="#rfc.section.8.6.2">Fields in Order Objects</a></li>
<li>8.6.3.   <a href="#rfc.section.8.6.3">Error Types</a></li>
<li>8.6.4.   <a href="#rfc.section.8.6.4">Resource Types</a></li>
<li>8.6.5.   <a href="#rfc.section.8.6.5">Identifier Types</a></li>
<li>8.6.6.   <a href="#rfc.section.8.6.6">Challenge Types</a></li>
</ul></ul><li>9.   <a href="#rfc.section.9">Security Considerations</a></li>
<ul><li>9.1.   <a href="#rfc.section.9.1">Threat model</a></li>
<li>9.2.   <a href="#rfc.section.9.2">Integrity of Authorizations</a></li>
<li>9.3.   <a href="#rfc.section.9.3">Denial-of-Service Considerations</a></li>
<li>9.4.   <a href="#rfc.section.9.4">Server-Side Request Forgery</a></li>
<li>9.5.   <a href="#rfc.section.9.5">CA Policy Considerations</a></li>
</ul><li>10.   <a href="#rfc.section.10">Operational Considerations</a></li>
<ul><li>10.1.   <a href="#rfc.section.10.1">DNS security</a></li>
<li>10.2.   <a href="#rfc.section.10.2">Default Virtual Hosts</a></li>
</ul><li>11.   <a href="#rfc.section.11">Acknowledgements</a></li>
<li>12.   <a href="#rfc.references">References</a></li>
<ul><li>12.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>12.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">Certificates <a href="#RFC5280">[RFC5280]</a> in the Web PKI are most commonly used to authenticate domain names.  Thus, certificate authorities in the Web PKI are trusted to verify that an applicant for a certificate legitimately represents the domain name(s) in the certificate.</p>
<p id="rfc.section.1.p.2">Different types of certificates reflect different kinds of CA verification of information about the certificate subject.  &#8220;Domain Validation&#8221; (DV) certificates are by far the most common type.  For DV validation, the CA merely verifies that the requester has effective control of the web server and/or DNS server for the domain, but does not explicitly attempt to verify their real-world identity.  (This is as opposed to &#8220;Organization Validation&#8221; (OV) and &#8220;Extended Validation&#8221; (EV) certificates, where the process is intended to also verify the real-world identity of the requester.)</p>
<p id="rfc.section.1.p.3">Existing Web PKI certificate authorities tend to run on a set of ad hoc protocols for certificate issuance and identity verification.  In the case of DV certificates, a typical user experience is something like:</p>
<p/>

<ul>
  <li>Generate a PKCS#10 <a href="#RFC2986">[RFC2986]</a> Certificate Signing Request (CSR).</li>
  <li>Cut-and-paste the CSR into a CA web page.</li>
  <li>Prove ownership of the domain by one of the following methods: <ul><li>Put a CA-provided challenge at a specific place on the web server.</li><li>Put a CA-provided challenge at a DNS location corresponding to the target domain.</li><li>Receive CA challenge at a (hopefully) administrator-controlled e-mail address corresponding to the domain and then respond to it on the CA&#8217;s web page.</li></ul></li>
  <li>Download the issued certificate and install it on their Web Server.</li>
</ul>
<p id="rfc.section.1.p.5">With the exception of the CSR itself and the certificates that are issued, these are all completely ad hoc procedures and are accomplished by getting the human user to follow interactive natural-language instructions from the CA rather than by machine-implemented published protocols.  In many cases, the instructions are difficult to follow and cause significant confusion.  Informal usability tests by the authors indicate that webmasters often need 1-3 hours to obtain and install a certificate for a domain.  Even in the best case, the lack of published, standardized mechanisms presents an obstacle to the wide deployment of HTTPS and other PKIX-dependent systems because it inhibits mechanization of tasks related to certificate issuance, deployment, and revocation.</p>
<p id="rfc.section.1.p.6">This document describes an extensible framework for automating the issuance and domain validation procedure, thereby allowing servers and infrastructural software to obtain certificates without user interaction.  Use of this protocol should radically simplify the deployment of HTTPS and the practicality of PKIX authentication for other protocols based on TLS <a href="#RFC5246">[RFC5246]</a>.</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#deployment-model-and-operator-experience" id="deployment-model-and-operator-experience">Deployment Model and Operator Experience</a></h1>
<p id="rfc.section.2.p.1">The guiding use case for ACME is obtaining certificates for Web sites (HTTPS <a href="#RFC2818">[RFC2818]</a>).  In this case, the user&#8217;s web server is intended to speak for one or more domains, and the process of certificate issuance is intended to verify that this server actually speaks for the domain(s).</p>
<p id="rfc.section.2.p.2">DV certificate validation commonly checks claims about properties related to control of a domain name &#8211; properties that can be observed by the certificate issuer in an interactive process that can be conducted purely online.  That means that under typical circumstances, all steps in the request, verification, and issuance process can be represented and performed by Internet protocols with no out-of-band human intervention.</p>
<p id="rfc.section.2.p.3">At time of writing, when deploying an HTTPS server, an operator typically gets a prompt to generate a self-signed certificate.  If the operator were instead deploying an ACME-compatible web server, the experience would be something like this:</p>
<p/>

<ul>
  <li>The ACME client prompts the operator for the intended domain name(s) that the web server is to stand for.</li>
  <li>The ACME client presents the operator with a list of CAs from which it could get a certificate.  (This list will change over time based on the capabilities of CAs and updates to ACME configuration.) The ACME client might prompt the operator for payment information at this point.</li>
  <li>The operator selects a CA.</li>
  <li>In the background, the ACME client contacts the CA and requests that a certificate be issued for the intended domain name(s).</li>
  <li>Once the CA is satisfied, the certificate is issued and the ACME client automatically downloads and installs it, potentially notifying the operator via e-mail, SMS, etc.</li>
  <li>The ACME client periodically contacts the CA to get updated certificates, stapled OCSP responses, or whatever else would be required to keep the server functional and its credentials up-to-date.</li>
</ul>
<p id="rfc.section.2.p.5">In this way, it would be nearly as easy to deploy with a CA-issued certificate as with a self-signed certificate. Furthermore, the maintenance of that CA-issued certificate would require minimal manual intervention.  Such close integration of ACME with HTTPS servers would allow the immediate and automated deployment of certificates as they are issued, sparing the human administrator from much of the time-consuming work described in the previous section.</p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#terminology" id="terminology">Terminology</a></h1>
<p id="rfc.section.3.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in RFC 2119 <a href="#RFC2119">[RFC2119]</a>.</p>
<p id="rfc.section.3.p.2">The two main roles in ACME are &#8220;client&#8221; and &#8220;server&#8221;.  The ACME client uses the protocol to request certificate management actions, such as issuance or revocation.  An ACME client therefore typically runs on a web server, mail server, or some other server system which requires valid TLS certificates.  The ACME server runs at a certification authority, and responds to client requests, performing the requested actions if the client is authorized.</p>
<p id="rfc.section.3.p.3">An ACME client is represented by an &#8220;account key pair&#8221;.  The client uses the private key of this key pair to sign all messages sent to the server.  The server uses the public key to verify the authenticity and integrity of messages from the client.</p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#protocol-overview" id="protocol-overview">Protocol Overview</a></h1>
<p id="rfc.section.4.p.1">ACME allows a client to request certificate management actions using a set of JSON messages carried over HTTPS.   In many ways, ACME functions much like a traditional CA, in which a user creates an account, requests a certificate, and proves control of the domains in that certificate in order for the CA to sign the requested certificate.</p>
<p id="rfc.section.4.p.2">The first phase of ACME is for the client to request an account with the ACME server.  The client generates an asymmetric key pair and requests a new account, optionally providing contact information, agreeing to terms of service, and/or associating the account with an existing account in another system. The creation request is signed with the generated private key to prove that the client controls it.</p>
<pre>
      Client                                                  Server

      Contact Information
      ToS Agreement
      Additional Data
      Signature                     -------&gt;

                                    &lt;-------                 Account
</pre>
<p id="rfc.section.4.p.3">Once an account is registered, there are three major steps the client needs to take to get a certificate:</p>
<p/>

<ol>
  <li>Submit an order for a certificate to be issued</li>
  <li>Prove control of any identifiers requested in the certificate</li>
  <li>Await issuance and download the issued certificate</li>
</ol>
<p id="rfc.section.4.p.5">The client&#8217;s order for a certificate describes the desired certificate using a PKCS#10 Certificate Signing Request (CSR) plus a few additional fields that capture semantics that are not supported in the CSR format.  If the server is willing to consider issuing such a certificate, it responds with a list of requirements that the client must satisfy before the certificate will be issued.</p>
<p id="rfc.section.4.p.6">For example, in most cases, the server will require the client to demonstrate that it controls the identifiers in the requested certificate.  Because there are many different ways to validate possession of different types of identifiers, the server will choose from an extensible set of challenges that are appropriate for the identifier being claimed.  The client responds with a set of responses that tell the server which challenges the client has completed.  The server then validates the challenges to check that the client has accomplished the challenge.</p>
<p id="rfc.section.4.p.7">Once the validation process is complete and the server is satisfied that the client has met its requirements, the server will issue the requested certificate and make it available to the client.</p>
<pre>
      Order
      Signature                     -------&gt;
                                                             Required
                                    &lt;-------           Authorizations

      Responses
      Signature                     -------&gt;

                          &lt;~~~~~~~~Validation~~~~~~~~&gt;

                                    &lt;-------             Certificate
</pre>
<p id="rfc.section.4.p.8">To revoke a certificate, the client sends a signed revocation request indicating the certificate to be revoked:</p>
<pre>
      Client                                                 Server

      Revocation request
      Signature                    --------&gt;

                                   &lt;--------                 Result
</pre>
<p id="rfc.section.4.p.9">Note that while ACME is defined with enough flexibility to handle different types of identifiers in principle, the primary use case addressed by this document is the case where domain names are used as identifiers.  For example, all of the identifier validation challenges described in <a href="#identifier-validation-challenges">Section 7</a> below address validation of domain names.  The use of ACME for other identifiers will require further specification, in order to describe how these identifiers are encoded in the protocol, and what types of validation challenges the server might require.</p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#message-transport" id="message-transport">Message Transport</a></h1>
<p id="rfc.section.5.p.1">Communications between an ACME client and an ACME server are done over HTTPS, using JSON Web Signature (JWS) <a href="#RFC7515">[RFC7515]</a> to provide some additional security properties for messages sent from the client to the server.  HTTPS provides server authentication and confidentiality.  With some ACME-specific extensions, JWS provides authentication of the client&#8217;s request payloads, anti-replay protection, and integrity for the HTTPS request URI.</p>
<h1 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a> <a href="#https-requests" id="https-requests">HTTPS Requests</a></h1>
<p id="rfc.section.5.1.p.1">Each ACME function is accomplished by the client sending a sequence of HTTPS requests to the server, carrying JSON messages <a href="#RFC2818">[RFC2818]</a><a href="#RFC7159">[RFC7159]</a>.  Use of HTTPS is REQUIRED.  Clients SHOULD support HTTP public key pinning <a href="#RFC7469">[RFC7469]</a>, and servers SHOULD emit pinning headers.  Each subsection of <a href="#certificate-management">Section 6</a> below describes the message formats used by the function, and the order in which messages are sent.</p>
<p id="rfc.section.5.1.p.2">In most HTTPS transactions used by ACME, the ACME client is the HTTPS client and the ACME server is the HTTPS server. The ACME server acts as an HTTP and HTTPS client when validating challenges via HTTP.</p>
<p id="rfc.section.5.1.p.3">ACME clients SHOULD send a User-Agent header in accordance with <a href="#RFC7231">[RFC7231]</a>, including the name and version of the ACME software in addition to the name and version of the underlying HTTP client software.</p>
<p id="rfc.section.5.1.p.4">ACME clients SHOULD send an Accept-Language header in accordance with <a href="#RFC7231">[RFC7231]</a> to enable localization of error messages.</p>
<p id="rfc.section.5.1.p.5">ACME servers that are intended to be generally accessible need to use Cross-Origin Resource Sharing (CORS) in order to be accessible from browser-based clients <a href="#W3C.CR-cors-20130129">[W3C.CR-cors-20130129]</a>.  Such servers SHOULD set the Access-Control-Allow-Origin header field to the value &#8220;*&#8221;.</p>
<p id="rfc.section.5.1.p.6">Binary fields in the JSON objects used by ACME are encoded using base64url encoding described in <a href="#RFC4648">[RFC4648]</a> Section 5, according to the profile specified in JSON Web Signature <a href="#RFC7515">[RFC7515]</a> Section 2. This encoding uses a URL safe character set. Trailing &#8216;=&#8217; characters MUST be stripped.</p>
<h1 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2.</a> <a href="#request-authentication" id="request-authentication">Request Authentication</a></h1>
<p id="rfc.section.5.2.p.1">All ACME requests with a non-empty body MUST encapsulate their payload in a JSON Web Signature (JWS) <a href="#RFC7515">[RFC7515]</a> object, signed (in most cases) using the account&#8217;s private key.  The server MUST verify the JWS before processing the request.  Encapsulating request bodies in JWS provides a simple authentication of requests.</p>
<p id="rfc.section.5.2.p.2">JWS objects sent in ACME requests MUST meet the following additional criteria:</p>
<p/>

<ul>
  <li>The JWS MUST be encoded using UTF-8</li>
  <li>The JWS MUST NOT have the value &#8220;none&#8221; in its &#8220;alg&#8221; field</li>
  <li>The JWS MUST NOT have a MAC-based algorithm in its &#8220;alg&#8221; field</li>
  <li>The JWS Protected Header MUST include the following fields: <ul><li>&#8220;alg&#8221;</li><li>&#8220;jwk&#8221; (only for requests to new-account and revoke-cert resources)</li><li>&#8220;kid&#8221; (for all other requests).</li><li>&#8220;nonce&#8221; (defined below)</li><li>&#8220;url&#8221; (defined below)</li></ul></li>
</ul>
<p id="rfc.section.5.2.p.4">The &#8220;jwk&#8221; and &#8220;kid&#8221; fields are mutually exclusive. Servers MUST reject requests that contain both.</p>
<p id="rfc.section.5.2.p.5">For new-account requests, and for revoke-cert requests authenticated by certificate key, there MUST be a &#8220;jwk&#8221; field.</p>
<p id="rfc.section.5.2.p.6">For all other requests, there MUST be a &#8220;kid&#8221; field. This field must contain the account URI received by POSTing to the new-account resource.</p>
<p id="rfc.section.5.2.p.7">Note that authentication via signed JWS request bodies implies that GET requests are not authenticated.  Servers MUST NOT respond to GET requests for resources that might be considered sensitive.</p>
<p id="rfc.section.5.2.p.8">If the client sends a JWS signed with an algorithm that the server does not support, then the server MUST return an error with status code 400 (Bad Request) and type &#8220;urn:ietf:params:acme:error:badSignatureAlgorithm&#8221;.  The problem document returned with the error MUST include an &#8220;algorithms&#8221; field with an array of supported &#8220;alg&#8221; values.</p>
<p id="rfc.section.5.2.p.9">In the examples below, JWS objects are shown in the JSON or flattened JSON serialization, with the protected header and payload expressed as base64url(content) instead of the actual base64-encoded value, so that the content is readable.</p>
<h1 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3.</a> <a href="#equivalence-of-jwks" id="equivalence-of-jwks">Equivalence of JWKs</a></h1>
<p id="rfc.section.5.3.p.1">At some points in the protocol, it is necessary for the server to determine whether two JSON Web Key (JWK) <a href="#RFC7517">[RFC7517]</a> objects represent the same key.  In performing these checks, the server MUST consider two JWKs to match if and only if they have the identical values in all fields included in the computation of a JWK thumbprint for that key. That is, the keys must have the same &#8220;kty&#8221; value and contain identical values in the fields used in the computation of a JWK thumbprint for that key type:</p>
<p/>

<ul>
  <li>&#8220;RSA&#8221;: &#8220;n&#8221;, &#8220;e&#8221;</li>
  <li>&#8220;EC&#8221;: &#8220;crv&#8221;, &#8220;x&#8221;, &#8220;y&#8221;</li>
</ul>
<p id="rfc.section.5.3.p.3">Note that this comparison is equivalent to computing the JWK thumbprints of the two keys and comparing thumbprints.  The only difference is that there is no requirement for a hash computation (and thus it is independent of the choice of hash function) and no risk of hash collision.</p>
<h1 id="rfc.section.5.4"><a href="#rfc.section.5.4">5.4.</a> <a href="#request-uri-integrity" id="request-uri-integrity">Request URI Integrity</a></h1>
<p id="rfc.section.5.4.p.1">It is common in deployment for the entity terminating TLS for HTTPS to be different from the entity operating the logical HTTPS server, with a &#8220;request routing&#8221; layer in the middle.  For example, an ACME CA might have a content delivery network terminate TLS connections from clients so that it can inspect client requests for denial-of-service protection.</p>
<p id="rfc.section.5.4.p.2">These intermediaries can also change values in the request that are not signed in the HTTPS request, e.g., the request URI and headers.  ACME uses JWS to provide an integrity mechanism, which protects against an intermediary changing the request URI to another ACME URI.</p>
<p id="rfc.section.5.4.p.3">As noted above, all ACME request objects carry a &#8220;url&#8221; parameter in their protected header.  This header parameter encodes the URL to which the client is directing the request.  On receiving such an object in an HTTP request, the server MUST compare the &#8220;url&#8221; parameter to the request URI.  If the two do not match, then the server MUST reject the request as unauthorized.</p>
<p id="rfc.section.5.4.p.4">Except for the directory resource, all ACME resources are addressed with URLs provided to the client by the server.  For these resources, the client MUST set the &#8220;url&#8221; field to the exact string provided by the server (rather than performing any re-encoding on the URL).  The server SHOULD perform the corresponding string equality check, configuring each resource with the URL string provided to clients and having the resource check that requests have the same string in their &#8220;url&#8221; fields.</p>
<h1 id="rfc.section.5.4.1"><a href="#rfc.section.5.4.1">5.4.1.</a> <a href="#url-url-jws-header-parameter" id="url-url-jws-header-parameter">&#8220;url&#8221; (URL) JWS header parameter</a></h1>
<p id="rfc.section.5.4.1.p.1">The &#8220;url&#8221; header parameter specifies the URL <a href="#RFC3986">[RFC3986]</a> to which this JWS object is directed.  The &#8220;url&#8221; parameter MUST be carried in the protected header of the JWS.  The value of the &#8220;url&#8221; header MUST be a JSON string representing the URL.</p>
<h1 id="rfc.section.5.5"><a href="#rfc.section.5.5">5.5.</a> <a href="#replay-protection" id="replay-protection">Replay protection</a></h1>
<p id="rfc.section.5.5.p.1">In order to protect ACME resources from any possible replay attacks, ACME requests have a mandatory anti-replay mechanism.  This mechanism is based on the server maintaining a list of nonces that it has issued to clients, and requiring any signed request from the client to carry such a nonce.</p>
<p id="rfc.section.5.5.p.2">An ACME server provides nonces to clients using the Replay-Nonce header field, as specified below.  The server MUST include a Replay-Nonce header field in every successful response to a POST request, and SHOULD provide it in error responses as well.</p>
<p id="rfc.section.5.5.p.3">Every JWS sent by an ACME client MUST include, in its protected header, the &#8220;nonce&#8221; header parameter, with contents as defined below.  As part of JWS verification, the ACME server MUST verify that the value of the &#8220;nonce&#8221; header is a value that the server previously provided in a Replay-Nonce header field.  Once a nonce value has appeared in an ACME request, the server MUST consider it invalid, in the same way as a value it had never issued.</p>
<p id="rfc.section.5.5.p.4">When a server rejects a request because its nonce value was unacceptable (or not present), it MUST provide HTTP status code 400 (Bad Request), and indicate the ACME error type &#8220;urn:ietf:params:acme:error:badNonce&#8221;.  An error response with the &#8220;badNonce&#8221; error type MUST include a Replay-Nonce header with a fresh nonce.  On receiving such a response, a client SHOULD retry the request using the new nonce.</p>
<p id="rfc.section.5.5.p.5">The precise method used to generate and track nonces is up to the server.  For example, the server could generate a random 128-bit value for each response, keep a list of issued nonces, and strike nonces from this list as they are used.</p>
<h1 id="rfc.section.5.5.1"><a href="#rfc.section.5.5.1">5.5.1.</a> <a href="#replay-nonce" id="replay-nonce">Replay-Nonce</a></h1>
<p id="rfc.section.5.5.1.p.1">The &#8220;Replay-Nonce&#8221; header field includes a server-generated value that the server can use to detect unauthorized replay in future client requests.  The server should generate the value provided in Replay-Nonce in such a way that they are unique to each message, with high probability.</p>
<p id="rfc.section.5.5.1.p.2">The value of the Replay-Nonce field MUST be an octet string encoded according to the base64url encoding described in Section 2 of <a href="#RFC7515">[RFC7515]</a>.  Clients MUST ignore invalid Replay-Nonce values.</p>
<pre>
  base64url = [A-Z] / [a-z] / [0-9] / "-" / "_"

  Replay-Nonce = *base64url
</pre>
<p id="rfc.section.5.5.1.p.3">The Replay-Nonce header field SHOULD NOT be included in HTTP request messages.</p>
<h1 id="rfc.section.5.5.2"><a href="#rfc.section.5.5.2">5.5.2.</a> <a href="#nonce-nonce-jws-header-parameter" id="nonce-nonce-jws-header-parameter">&#8220;nonce&#8221; (Nonce) JWS header parameter</a></h1>
<p id="rfc.section.5.5.2.p.1">The &#8220;nonce&#8221; header parameter provides a unique value that enables the verifier of a JWS to recognize when replay has occurred. The &#8220;nonce&#8221; header parameter MUST be carried in the protected header of the JWS.</p>
<p id="rfc.section.5.5.2.p.2">The value of the &#8220;nonce&#8221; header parameter MUST be an octet string, encoded according to the base64url encoding described in Section 2 of <a href="#RFC7515">[RFC7515]</a>.  If the value of a &#8220;nonce&#8221; header parameter is not valid according to this encoding, then the verifier MUST reject the JWS as malformed.</p>
<h1 id="rfc.section.5.6"><a href="#rfc.section.5.6">5.6.</a> <a href="#rate-limits" id="rate-limits">Rate limits</a></h1>
<p id="rfc.section.5.6.p.1">Creation of resources can be rate limited to ensure fair usage and prevent abuse.  Once the rate limit is exceeded, the server MUST respond with an error with the type &#8220;urn:ietf:params:acme:error:rateLimited&#8221;.  Additionally, the server SHOULD send a &#8220;Retry-After&#8221; header indicating when the current request may succeed again.  If multiple rate limits are in place, that is the time where all rate limits allow access again for the current request with exactly the same parameters.</p>
<p id="rfc.section.5.6.p.2">In addition to the human readable &#8220;detail&#8221; field of the error response, the server MAY send one or multiple tokens in the &#8220;Link&#8221; header pointing to documentation about the specific hit rate limits using the &#8220;rate-limit&#8221; relation.</p>
<h1 id="rfc.section.5.7"><a href="#rfc.section.5.7">5.7.</a> <a href="#errors" id="errors">Errors</a></h1>
<p id="rfc.section.5.7.p.1">Errors can be reported in ACME both at the HTTP layer and within challenge objects as defined in {{identifier-validation-challenges}. ACME servers can return responses with an HTTP error response code (4XX or 5XX). For example:  If the client submits a request using a method not allowed in this document, then the server MAY return status code 405 (Method Not Allowed).</p>
<p id="rfc.section.5.7.p.2">When the server responds with an error status, it SHOULD provide additional information using problem document <a href="#RFC7807">[RFC7807]</a>.  To facilitate automatic response to errors, this document defines the following standard tokens for use in the &#8220;type&#8221; field (within the &#8220;urn:ietf:params:acme:error:&#8221; namespace):</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="left">Type</th>
      <th class="left">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">badCSR</td>
      <td class="left">The CSR is unacceptable (e.g., due to a short key)</td>
    </tr>
    <tr>
      <td class="left">badNonce</td>
      <td class="left">The client sent an unacceptable anti-replay nonce</td>
    </tr>
    <tr>
      <td class="left">badSignatureAlgorithm</td>
      <td class="left">The JWS was signed with an algorithm the server does not support</td>
    </tr>
    <tr>
      <td class="left">caa</td>
      <td class="left">CAA records forbid the CA from issuing</td>
    </tr>
    <tr>
      <td class="left">connection</td>
      <td class="left">The server could not connect to validation target</td>
    </tr>
    <tr>
      <td class="left">dnssec</td>
      <td class="left">DNSSEC validation failed</td>
    </tr>
    <tr>
      <td class="left">invalidContact</td>
      <td class="left">The contact URI for an account was invalid</td>
    </tr>
    <tr>
      <td class="left">malformed</td>
      <td class="left">The request message was malformed</td>
    </tr>
    <tr>
      <td class="left">rateLimited</td>
      <td class="left">The request exceeds a rate limit</td>
    </tr>
    <tr>
      <td class="left">rejectedIdentifier</td>
      <td class="left">The server will not issue for the identifier</td>
    </tr>
    <tr>
      <td class="left">serverInternal</td>
      <td class="left">The server experienced an internal error</td>
    </tr>
    <tr>
      <td class="left">tls</td>
      <td class="left">The server received a TLS error during validation</td>
    </tr>
    <tr>
      <td class="left">unauthorized</td>
      <td class="left">The client lacks sufficient authorization</td>
    </tr>
    <tr>
      <td class="left">unknownHost</td>
      <td class="left">The server could not resolve a domain name</td>
    </tr>
    <tr>
      <td class="left">unsupportedIdentifier</td>
      <td class="left">Identifier is not supported, but may be in future</td>
    </tr>
    <tr>
      <td class="left">userActionRequired</td>
      <td class="left">The user visit the &#8220;instance&#8221; URL and take actions specified there</td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.5.7.p.3">This list is not exhaustive. The server MAY return errors whose &#8220;type&#8221; field is set to a URI other than those defined above.  Servers MUST NOT use the ACME URN namespace for errors other than the standard types.  Clients SHOULD display the &#8220;detail&#8221; field of all errors.</p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#certificate-management" id="certificate-management">Certificate Management</a></h1>
<p id="rfc.section.6.p.1">In this section, we describe the certificate management functions that ACME enables:</p>
<p/>

<ul>
  <li>Account Creation</li>
  <li>Ordering a Certificate</li>
  <li>Identifier Authorization</li>
  <li>Certificate Issuance</li>
  <li>Certificate Revocation</li>
</ul>
<h1 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a> <a href="#resources" id="resources">Resources</a></h1>
<p id="rfc.section.6.1.p.1">ACME is structured as a REST application with a few types of resources:</p>
<p/>

<ul>
  <li>Account resources, representing information about an account (<a href="#account-objects">Section 6.1.2</a>, <a href="#account-creation">Section 6.3</a>)</li>
  <li>Order resources, representing an account&#8217;s requests to issue certificates (<a href="#order-objects">Section 6.1.3</a>)</li>
  <li>Authorization resources, representing an account&#8217;s authorization to act for an identifier (<a href="#authorization-objects">Section 6.1.4</a>)</li>
  <li>Challenge resources, representing a challenge to prove control of an identifier (<a href="#identifier-authorization">Section 6.5</a>)</li>
  <li>Certificate resources, representing issued certificates (<a href="#downloading-the-certificate">Section 6.4.2</a>)</li>
  <li>A &#8220;directory&#8221; resource (<a href="#directory">Section 6.1.1</a>)</li>
  <li>A &#8220;new-nonce&#8221; resource (<a href="#getting-a-nonce">Section 6.2</a>)</li>
  <li>A &#8220;new-account&#8221; resource (<a href="#account-creation">Section 6.3</a>)</li>
  <li>A &#8220;new-order&#8221; resource (<a href="#applying-for-certificate-issuance">Section 6.4</a>)</li>
  <li>A &#8220;revoke-certificate&#8221; resource (<a href="#certificate-revocation">Section 6.6</a>)</li>
  <li>A &#8220;key-change&#8221; resource (<a href="#account-key-roll-over">Section 6.3.3</a>)</li>
</ul>
<p id="rfc.section.6.1.p.3">The server MUST provide &#8220;directory&#8221; and &#8220;new-nonce&#8221; resources.</p>
<p id="rfc.section.6.1.p.4">ACME uses different URIs for different management functions. Each function is listed in a directory along with its corresponding URI, so clients only need to be configured with the directory URI.  These URIs are connected by a few different link relations <a href="#RFC5988">[RFC5988]</a>.</p>
<p id="rfc.section.6.1.p.5">The &#8220;up&#8221; link relation is used with challenge resources to indicate the authorization resource to which a challenge belongs.  It is also used from certificate resources to indicate a resource from which the client may fetch a chain of CA certificates that could be used to validate the certificate in the original resource.</p>
<p id="rfc.section.6.1.p.6">The &#8220;directory&#8221; link relation is present on all resources other than the directory and indicates the directory URL.</p>
<p id="rfc.section.6.1.p.7">The following diagram illustrates the relations between resources on an ACME server.  For the most part, these relations are expressed by URLs provided as strings in the resources&#8217; JSON representations.  Lines with labels in quotes indicate HTTP link relations.</p>
<pre>
                               directory
                                   |
                                   |--&gt; new-nonce
                                   |
       --------------------------------------------------+
       |          |          |                           |
       |          |          |                           |
       V          V          V                           V
 new-account  new-authz  new-order                  revoke-cert
       |          |          |                           ^
       |          |          |    "author"               | "revoke"
       V          |          V   &lt;--------               |
      acct        |        order --------&gt; cert ---------+
                  |         | ^              |
                  |         | | "up"         | "up"
                  |         V |              V
                  +------&gt; authz         cert-chain
                            | ^
                            | | "up"
                            V |
                          challenge
</pre>
<p id="rfc.section.6.1.p.8">The following table illustrates a typical sequence of requests required to establish a new account with the server, prove control of an identifier, issue a certificate, and fetch an updated certificate some time after issuance.  The &#8220;-&gt;&#8221; is a mnemonic for a Location header pointing to a created resource.</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="left">Action</th>
      <th class="left">Request</th>
      <th class="left">Response</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">Get a nonce</td>
      <td class="left">HEAD new-nonce</td>
      <td class="left">204</td>
    </tr>
    <tr>
      <td class="left">Create account</td>
      <td class="left">POST new-account</td>
      <td class="left">201 -&gt; account</td>
    </tr>
    <tr>
      <td class="left">Submit an order</td>
      <td class="left">POST new-order</td>
      <td class="left">201 -&gt; order</td>
    </tr>
    <tr>
      <td class="left">Fetch challenges</td>
      <td class="left">GET  authz</td>
      <td class="left">200</td>
    </tr>
    <tr>
      <td class="left">Respond to challenge</td>
      <td class="left">POST challenge</td>
      <td class="left">200</td>
    </tr>
    <tr>
      <td class="left">Poll for status</td>
      <td class="left">GET  authz</td>
      <td class="left">200</td>
    </tr>
    <tr>
      <td class="left">Check for new cert</td>
      <td class="left">GET  cert</td>
      <td class="left">200</td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.6.1.p.9">The remainder of this section provides the details of how these resources are structured and how the ACME protocol makes use of them.</p>
<h1 id="rfc.section.6.1.1"><a href="#rfc.section.6.1.1">6.1.1.</a> <a href="#directory" id="directory">Directory</a></h1>
<p id="rfc.section.6.1.1.p.1">In order to help clients configure themselves with the right URIs for each ACME operation, ACME servers provide a directory object. This should be the only URL needed to configure clients. It is a JSON dictionary, whose keys are drawn from the following table and whose values are the corresponding URLs.</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="left">Key</th>
      <th class="left">URL in value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">new-nonce</td>
      <td class="left">New nonce</td>
    </tr>
    <tr>
      <td class="left">new-account</td>
      <td class="left">New account</td>
    </tr>
    <tr>
      <td class="left">new-order</td>
      <td class="left">New order</td>
    </tr>
    <tr>
      <td class="left">new-authz</td>
      <td class="left">New authorization</td>
    </tr>
    <tr>
      <td class="left">revoke-cert</td>
      <td class="left">Revoke certificate</td>
    </tr>
    <tr>
      <td class="left">key-change</td>
      <td class="left">Key change</td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.6.1.1.p.2">There is no constraint on the actual URI of the directory except that it should be different from the other ACME server resources&#8217; URIs, and that it should not clash with other services. For instance:</p>
<p/>

<ul>
  <li>a host which functions as both an ACME and Web server may want to keep the root path &#8220;/&#8221; for an HTML &#8220;front page&#8221;, and and place the ACME directory under path &#8220;/acme&#8221;.</li>
  <li>a host which only functions as an ACME server could place the directory under path &#8220;/&#8221;.</li>
</ul>
<p id="rfc.section.6.1.1.p.4">The dictionary MAY additionally contain a key &#8220;meta&#8221;. If present, it MUST be a JSON dictionary; each item in the dictionary is an item of metadata relating to the service provided by the ACME server.</p>
<p id="rfc.section.6.1.1.p.5">The following metadata items are defined, all of which are OPTIONAL:</p>
<p/>

<dl>
  <dt>&#8220;terms-of-service&#8221; (optional, string):</dt>
  <dd style="margin-left: 8">A URI identifying the current terms of service.</dd>
  <dt>&#8220;website&#8221; (optional, string):</dt>
  <dd style="margin-left: 8">An HTTP or HTTPS URL locating a website providing more information about the ACME server.</dd>
  <dt>&#8220;caa-identities&#8221; (optional, array of string):</dt>
  <dd style="margin-left: 8">Each string MUST be a lowercase hostname which the ACME server recognizes as referring to itself for the purposes of CAA record validation as defined in <a href="#RFC6844">[RFC6844]</a>.  This allows clients to determine the correct issuer domain name to use when configuring CAA records.</dd>
</dl>
<p id="rfc.section.6.1.1.p.7">Clients access the directory by sending a GET request to the directory URI.</p>
<pre>
HTTP/1.1 200 OK
Content-Type: application/json

{
  "new-nonce": "https://example.com/acme/new-nonce",
  "new-account": "https://example.com/acme/new-account",
  "new-order": "https://example.com/acme/new-order",
  "new-authz": "https://example.com/acme/new-authz",
  "revoke-cert": "https://example.com/acme/revoke-cert",
  "key-change": "https://example.com/acme/key-change",
  "meta": {
    "terms-of-service": "https://example.com/acme/terms",
    "website": "https://www.example.com/",
    "caa-identities": ["example.com"]
  }
}
</pre>
<h1 id="rfc.section.6.1.2"><a href="#rfc.section.6.1.2">6.1.2.</a> <a href="#account-objects" id="account-objects">Account Objects</a></h1>
<p id="rfc.section.6.1.2.p.1">An ACME account resource represents a set of metadata associated with an account.  Account resources have the following structure:</p>
<p/>

<dl>
  <dt>key (required, dictionary):</dt>
  <dd style="margin-left: 8">The public key of the account&#8217;s key pair, encoded as a JSON Web Key object <a href="#RFC7517">[RFC7517]</a>. The client may not directly update this field, but must use the key-change resource instead.</dd>
  <dt>status (required, string):</dt>
  <dd style="margin-left: 8">The status of this account. Possible values are: &#8220;valid&#8221;, &#8220;deactivated&#8221;, and &#8220;revoked&#8221;.  The value &#8220;deactivated&#8221; should be used to indicate user initiated deactivation whereas &#8220;revoked&#8221; should be used to indicate administratively initiated deactivation.</dd>
  <dt>contact (optional, array of string):</dt>
  <dd style="margin-left: 8">An array of URIs that the server can use to contact the client for issues related to this account. For example, the server may wish to notify the client about server-initiated revocation or certificate expiration.</dd>
  <dt>terms-of-service-agreed (optional, boolean):</dt>
  <dd style="margin-left: 8">Including this field in a new-account request, with a value of true, indicates the client&#8217;s agreement with the terms of service. This field is not updateable by the client.</dd>
  <dt>orders (required, string):</dt>
  <dd style="margin-left: 8">A URI from which a list of orders submitted by this account can be fetched via a GET request, as described in <a href="#orders-list">Section 6.1.2.1</a>.</dd>
</dl>
<pre>
{
  "contact": [
    "mailto:cert-admin@example.com",
    "tel:+12025551212"
  ],
  "terms-of-service-agreed": true,
  "orders": "https://example.com/acme/acct/1/orders"
}
</pre>
<h1 id="rfc.section.6.1.2.1"><a href="#rfc.section.6.1.2.1">6.1.2.1.</a> <a href="#orders-list" id="orders-list">Orders List</a></h1>
<p id="rfc.section.6.1.2.1.p.1">Each account object includes an &#8220;orders&#8221; URI from which a list of orders created by the account can be fetched via GET request. The result of the GET request MUST be a JSON object whose &#8220;orders&#8221; field is an array of URIs, each identifying an order belonging to the account.  The server SHOULD include pending orders, and SHOULD NOT include orders that are invalid in the array of URIs. The server MAY return an incomplete list, along with a Link header with a &#8220;next&#8221; link relation indicating where further entries can be acquired.</p>
<pre>
HTTP/1.1 200 OK
Content-Type: application/json
Link: href="/acme/acct/1/orders?cursor=2", rel="next"

{
  "orders": [
    "https://example.com/acme/acct/1/order/1",
    "https://example.com/acme/acct/1/order/2",
    /* 47 more URLs not shown for example brevity */
    "https://example.com/acme/acct/1/order/50"
  ]
}
</pre>
<h1 id="rfc.section.6.1.3"><a href="#rfc.section.6.1.3">6.1.3.</a> <a href="#order-objects" id="order-objects">Order Objects</a></h1>
<p id="rfc.section.6.1.3.p.1">An ACME order object represents a client&#8217;s request for a certificate, and is used to track the progress of that order through to issuance.  Thus, the object contains information about the requested certificate, the authorizations that the server requires the client to complete, and any certificates that have resulted from this order.</p>
<p/>

<dl>
  <dt>status (required, string):</dt>
  <dd style="margin-left: 8">The status of this order.  Possible values are: &#8220;pending&#8221;, &#8220;processing&#8221;, &#8220;valid&#8221;, and &#8220;invalid&#8221;.</dd>
  <dt>expires (optional, string):</dt>
  <dd style="margin-left: 8">The timestamp after which the server will consider this order invalid, encoded in the format specified in RFC 3339 <a href="#RFC3339">[RFC3339]</a>.  This field is REQUIRED for objects with &#8220;pending&#8221; or &#8220;valid&#8221; in the status field.</dd>
  <dt>csr (required, string):</dt>
  <dd style="margin-left: 8">A CSR encoding the parameters for the certificate being requested <a href="#RFC2986">[RFC2986]</a>.  The CSR is sent in the base64url-encoded version of the DER format. (Note: Because this field uses base64url, and does not include headers, it is different from PEM.)</dd>
  <dt>notBefore (optional, string):</dt>
  <dd style="margin-left: 8">The requested value of the notBefore field in the certificate, in the date format defined in <a href="#RFC3339">[RFC3339]</a>.</dd>
  <dt>notAfter (optional, string):</dt>
  <dd style="margin-left: 8">The requested value of the notAfter field in the certificate, in the date format defined in <a href="#RFC3339">[RFC3339]</a>.</dd>
  <dt>authorizations (required, array of string):</dt>
  <dd style="margin-left: 8">For pending orders, the authorizations that the client needs to complete before the requested certificate can be issued (see <a href="#identifier-authorization">Section 6.5</a>).  For final orders, the authorizations that were completed.  Each entry is a URL from which an authorization can be fetched with a GET request.</dd>
  <dt>certificate (optional, string):</dt>
  <dd style="margin-left: 8">A URL for the certificate that has been issued in response to this order.</dd>
</dl>
<pre>
{
  "status": "pending",
  "expires": "2015-03-01T14:09:00Z",

  "csr": "jcRf4uXra7FGYW5ZMewvV...rhlnznwy8YbpMGqwidEXfE",
  "notBefore": "2016-01-01T00:00:00Z",
  "notAfter": "2016-01-08T00:00:00Z",

  "authorizations": [
    "https://example.com/acme/authz/1234",
    "https://example.com/acme/authz/2345"
  ],

  "certificate": "https://example.com/acme/cert/1234"
}
</pre>
<p id="rfc.section.6.1.3.p.3">The elements of the &#8220;authorizations&#8221; array are immutable once set.  The server MUST NOT change the contents of the &#8220;authorizations&#8221; array after it is created.  If a client observes a change in the contents of the &#8220;authorizations&#8221; array, then it SHOULD consider the order invalid.</p>
<p id="rfc.section.6.1.3.p.4">The &#8220;authorizations&#8221; array in the challenge SHOULD reflect all authorizations that the CA takes into account in deciding to issue, even if some authorizations were fulfilled in earlier orders or in pre-authorization transactions.  For example, if a CA allows multiple orders to be fulfilled based on a single authorization transaction, then it SHOULD reflect that authorization in all of the order.</p>
<h1 id="rfc.section.6.1.4"><a href="#rfc.section.6.1.4">6.1.4.</a> <a href="#authorization-objects" id="authorization-objects">Authorization Objects</a></h1>
<p id="rfc.section.6.1.4.p.1">An ACME authorization object represents a server&#8217;s authorization for an account to represent an identifier.  In addition to the identifier, an authorization includes several metadata fields, such as the status of the authorization (e.g., &#8220;pending&#8221;, &#8220;valid&#8221;, or &#8220;revoked&#8221;) and which challenges were used to validate possession of the identifier.</p>
<p id="rfc.section.6.1.4.p.2">The structure of an ACME authorization resource is as follows:</p>
<p/>

<dl>
  <dt>identifier (required, object):</dt>
  <dd style="margin-left: 8">The identifier that the account is authorized to represent <dl><dt>type (required, string):</dt><dd style="margin-left: 8">The type of identifier.</dd><dt>value (required, string):</dt><dd style="margin-left: 8">The identifier itself.</dd></dl><p> </p></dd>
  <dt>status (required, string):</dt>
  <dd style="margin-left: 8">The status of this authorization.  Possible values are: &#8220;pending&#8221;, &#8220;processing&#8221;, &#8220;valid&#8221;, &#8220;invalid&#8221; and &#8220;revoked&#8221;.  If this field is missing, then the default value is &#8220;pending&#8221;.</dd>
  <dt>expires (optional, string):</dt>
  <dd style="margin-left: 8">The timestamp after which the server will consider this authorization invalid, encoded in the format specified in RFC 3339 <a href="#RFC3339">[RFC3339]</a>.  This field is REQUIRED for objects with &#8220;valid&#8221; in the &#8220;status&#8221; field.</dd>
  <dt>scope (optional, string):</dt>
  <dd style="margin-left: 8">If this field is present, then it MUST contain a URI for an order resource, such that this authorization is only valid for that resource.  If this field is absent, then the CA MUST consider this authorization valid for all orders until the authorization expires.</dd>
  <dt>challenges (required, array):</dt>
  <dd style="margin-left: 8">The challenges that the client can fulfill in order to prove possession of the identifier (for pending authorizations).  For final authorizations, the challenges that were used.  Each array entry is a dictionary with parameters required to validate the challenge.  A client should attempt to fulfill at most one of these challenges, and a server should consider any one of the challenges sufficient to make the authorization valid.</dd>
</dl>
<p id="rfc.section.6.1.4.p.4">The only type of identifier defined by this specification is a fully-qualified domain name (type: &#8220;dns&#8221;). The value of the identifier MUST be the ASCII representation of the domain name. If a domain name contains Unicode characters it MUST be encoded using the rules defined in <a href="#RFC3492">[RFC3492]</a>. Servers MUST verify any identifier values that begin with the ASCII Compatible Encoding prefix &#8220;xn&#8211;&#8221; as defined in <a href="#RFC5890">[RFC5890]</a> are properly encoded. Wildcard domain names (with &#8220;*&#8221; as the first label) MUST NOT be included in authorization objects.</p>
<p><a href="#identifier-validation-challenges">Section 7</a> describes a set of challenges for domain name validation.</p>
<pre>
{
  "status": "valid",
  "expires": "2015-03-01T14:09:00Z",

  "identifier": {
    "type": "dns",
    "value": "example.org"
  },

  "challenges": [
    {
      "type": "http-01",
      "status": "valid",
      "validated": "2014-12-01T12:05:00Z",
      "keyAuthorization": "SXQe-2XODaDxNR...vb29HhjjLPSggwiE"
    }
  ]
}
</pre>
<h1 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2.</a> <a href="#getting-a-nonce" id="getting-a-nonce">Getting a Nonce</a></h1>
<p id="rfc.section.6.2.p.1">Before sending a POST request to the server, an ACME client needs to have a fresh anti-replay nonce to put in the &#8220;nonce&#8221; header of the JWS.  In most cases, the client will have gotten a nonce from a previous request.  However, the client might sometimes need to get a new nonce, e.g., on its first request to the server or if an existing nonce is no longer valid.</p>
<p id="rfc.section.6.2.p.2">To get a fresh nonce, the client sends a HEAD request to the new-nonce resource on the server.  The server&#8217;s response MUST include a Replay-Nonce header field containing a fresh nonce, and SHOULD have status code 204 (No Content).  The server SHOULD also respond to GET requests for this resource, returning an empty body (while still providing a Replay-Nonce header).</p>
<pre>
HEAD /acme/new-nonce HTTP/1.1
Host: example.com

HTTP/1.1 204 No Content
Replay-Nonce: oFvnlFP1wIhRlYS2jTaXbA
Cache-Control: no-store
</pre>
<p id="rfc.section.6.2.p.3">Proxy caching of responses from the new-nonce resource can cause clients receive the same nonce repeatedly, leading to badNonce errors.  The server MUST include a Cache-Control header field with the &#8220;no-store&#8221; directive in responses for the new-nonce resource, in order to prevent caching of this resource.</p>
<h1 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3.</a> <a href="#account-creation" id="account-creation">Account Creation</a></h1>
<p id="rfc.section.6.3.p.1">A client creates a new account with the server by sending a POST request to the server&#8217;s new-account URI.  The body of the request is a stub account object containing only the &#8220;contact&#8221; field.</p>
<pre>
POST /acme/new-account HTTP/1.1
Host: example.com
Content-Type: application/jose+json

{
  "protected": base64url({
    "alg": "ES256",
    "jwk": {...},
    "nonce": "6S8IqOGY7eL2lsGoTZYifg",
    "url": "https://example.com/acme/new-account"
  }),
  "payload": base64url({
    "terms-of-service-agreed": true,
    "contact": [
      "mailto:cert-admin@example.com",
      "tel:+12025551212"
    ]
  }),
  "signature": "RZPOnYoPs1PhjszF...-nh6X1qtOFPB519I"
}
</pre>
<p id="rfc.section.6.3.p.2">The server MUST ignore any values provided in the &#8220;key&#8221;, and &#8220;orders&#8221; fields in account bodies sent by the client, as well as any other fields that it does not recognize.  If new fields are specified in the future, the specification of those fields MUST describe whether they can be provided by the client.</p>
<p id="rfc.section.6.3.p.3">In general, the server MUST ignore any fields in the request object that it does not recognize.  In particular, it MUST NOT reflect unrecognized fields in the resulting account object.  This allows clients to detect when servers do not support an extension field.</p>
<p id="rfc.section.6.3.p.4">The server SHOULD validate that the contact URLs in the &#8220;contact&#8221; field are valid and supported by the server.  If the client provides the server with an invalid or unsupported contact URL, then the server MUST return an error of type &#8220;invalidContact&#8221;, with a description describing the error and what types of contact URL the server considers acceptable.</p>
<p id="rfc.section.6.3.p.5">The server creates an account object with the included contact information.  The &#8220;key&#8221; element of the account is set to the public key used to verify the JWS (i.e., the &#8220;jwk&#8221; element of the JWS header).  The server returns this account object in a 201 (Created) response, with the account URI in a Location header field.</p>
<p id="rfc.section.6.3.p.6">If the server already has an account registered with the provided account key, then it MUST return a 200 (OK) response and provide the URI of that account in a Content-Location header field.  This allows a client that has an account key but not the corresponding account URI to recover the account URI.</p>
<p id="rfc.section.6.3.p.7">If the server wishes to present the client with terms under which the ACME service is to be used, it MUST indicate the URI where such terms can be accessed in the &#8220;terms-of-service&#8221; subfield of the &#8220;meta&#8221; field in the directory object, and the server MUST reject new-account requests that do not have the &#8220;terms-of-service-agreed&#8221; set to &#8220;true&#8221;.  Clients SHOULD NOT automatically agree to terms by default.  Rather, they SHOULD require some user interaction for agreement to terms.</p>
<pre>
HTTP/1.1 201 Created
Content-Type: application/json
Replay-Nonce: D8s4D2mLs8Vn-goWuPQeKA
Location: https://example.com/acme/acct/1
Link: &lt;https://example.com/acme/some-directory&gt;;rel="directory"

{
  "key": { /* JWK from JWS header */ },
  "status": "valid",

  "contact": [
    "mailto:cert-admin@example.com",
    "tel:+12025551212"
  ]
}
</pre>
<p id="rfc.section.6.3.p.8">If the client wishes to update this information in the future, it sends a POST request with updated information to the account URI.  The server MUST ignore any updates to the &#8220;key&#8221;, or &#8220;order&#8221; fields or any other fields it does not recognize. The server MUST verify that the request is signed with the private key corresponding to the &#8220;key&#8221; field of the request before updating the account object.</p>
<p id="rfc.section.6.3.p.9">For example, to update the contact information in the above account, the client could send the following request:</p>
<pre>
POST /acme/acct/1 HTTP/1.1
Host: example.com
Content-Type: application/jose+json

{
  "protected": base64url({
    "alg": "ES256",
    "kid": "https://example.com/acme/acct/1",
    "nonce": "ax5RnthDqp_Yf4_HZnFLmA",
    "url": "https://example.com/acme/acct/1"
  }),
  "payload": base64url({
    "contact": [
      "mailto:certificates@example.com",
      "tel:+12125551212"
    ]
  }),
  "signature": "hDXzvcj8T6fbFbmn...rDzXzzvzpRy64N0o"
}
</pre>
<p id="rfc.section.6.3.p.10">Servers SHOULD NOT respond to GET requests for account resources as these requests are not authenticated.  If a client wishes to query the server for information about its account (e.g., to examine the &#8220;contact&#8221; or &#8220;certificates&#8221; fields), then it SHOULD do so by sending a POST request with an empty update.  That is, it should send a JWS whose payload is trivial ({}).</p>
<h1 id="rfc.section.6.3.1"><a href="#rfc.section.6.3.1">6.3.1.</a> <a href="#changes-of-terms-of-service" id="changes-of-terms-of-service">Changes of Terms of Service</a></h1>
<p id="rfc.section.6.3.1.p.1">As described above, a client can indicate its agreement with the CA&#8217;s terms of service by setting the &#8220;terms-of-service-agreed&#8221; field in its account object to &#8220;true&#8221;.</p>
<p id="rfc.section.6.3.1.p.2">If the server has changed its terms of service since a client initially agreed, and the server is unwilling to process a request without explicit agreement to the new terms, then it MUST return an error response with status code 403 (Forbidden) and type &#8220;urn:ietf:params:acme:error:userActionRequired&#8221;.  This response MUST include a Link header with link relation &#8220;terms-of-service&#8221; and the latest terms-of-service URL.</p>
<p id="rfc.section.6.3.1.p.3">The problem document returned with the error MUST also include an &#8220;instance&#8221; field, indicating a URL that the client should direct a human user to visit in order for instructions on how to agree to the terms.</p>
<pre>
HTTP/1.1 403 Forbidden
Replay-Nonce: IXVHDyxIRGcTE0VSblhPzw
Content-Type: application/problem+json
Content-Language: en

{
  "type": "urn:ietf:params:acme:error:userActionRequired",
  "detail": "Terms of service have changed",
  "instance": "http://example.com/agreement/?token=W8Ih3PswD-8"
}
</pre>
<h1 id="rfc.section.6.3.2"><a href="#rfc.section.6.3.2">6.3.2.</a> <a href="#external-account-binding" id="external-account-binding">External Account Binding</a></h1>
<p id="rfc.section.6.3.2.p.1">The server MAY require a value to be present for the &#8220;external-account-binding&#8221; field.  This can be used to an ACME account with an existing account in a non-ACME system, such as a CA customer database.</p>
<p id="rfc.section.6.3.2.p.2">To enable ACME account binding, a CA needs to provision the ACME client with a MAC key and a key identifier.  The key identifier MUST be an ASCII string.  The MAC key SHOULD be provided in base64url-encoded form, to maximize compatibility between provisioning systems and ACME clients.</p>
<p id="rfc.section.6.3.2.p.3">The ACME client then computes a binding JWS to indicate the external account&#8217;s approval of the ACME account key.  The payload of this JWS is the account key being registered, in JWK form.  The protected header of the JWS MUST meet the following criteria:</p>
<p/>

<ul>
  <li>The &#8220;alg&#8221; field MUST indicate a MAC-based algorithm</li>
  <li>The &#8220;kid&#8221; field MUST contain the key identifier provided by the CA</li>
  <li>The &#8220;nonce&#8221; field MUST NOT be present</li>
  <li>The &#8220;url&#8221; field MUST be set to the same value as the outer JWS</li>
</ul>
<p id="rfc.section.6.3.2.p.5">The &#8220;signature&#8221; field of the JWS will contain the MAC value computed with the MAC key provided by the CA.</p>
<pre>
POST /acme/new-account HTTP/1.1
Host: example.com
Content-Type: application/jose+json

{
  "protected": base64url({
    "alg": "ES256",
    "jwk": /* account key */,
    "nonce": "K60BWPrMQG9SDxBDS_xtSw",
    "url": "https://example.com/acme/new-account"
  }),
  "payload": base64url({
    "contact": ["mailto:example@anonymous.invalid"],
    "terms-of-service-agreed": true,

    "external-account-binding": {
      "protected": base64url({
        "alg": "HS256",
        "kid": /* key identifier from CA */,
        "url": "https://example.com/acme/new-account"
      }),
      "payload": base64url(/* same as in "jwk" above */),
      "signature": /* MAC using MAC key from CA */
    }
  }),
  "signature": "5TWiqIYQfIDfALQv...x9C2mg8JGPxl5bI4"
}
</pre>
<p id="rfc.section.6.3.2.p.6">When a CA receives a new-account request containing an &#8220;external-account-binding&#8221; field, it decides whether or not to verify the binding.  If the CA does not verify the binding, then it MUST NOT reflect the &#8220;external-account-binding&#8221; field in the resulting account object (if any).  To verify the account binding, the CA MUST take the following steps:</p>
<p/>

<ol>
  <li>Verify that the value of the field is a well-formed JWS</li>
  <li>Verify that the JWS protected meets the above criteria</li>
  <li>Retrieve the MAC key corresponding to the key identifier in the &#8220;kid&#8221; field</li>
  <li>Verify that the MAC on the JWS verifies using that MAC key</li>
  <li>Verify that the payload of the JWS represents the same key as was used to verify the outer JWS (i.e., the &#8220;jwk&#8221; field of the outer JWS)</li>
</ol>
<p id="rfc.section.6.3.2.p.8">If all of these checks pass and the CA creates a new account, then the CA may consider the new account associated with the external account corresponding to the MAC key, and MUST reflect value of the &#8220;external-account-binding&#8221; field in the resulting account object.  If any of these checks fail, then the CA MUST reject the new-account request.</p>
<h1 id="rfc.section.6.3.3"><a href="#rfc.section.6.3.3">6.3.3.</a> <a href="#account-key-roll-over" id="account-key-roll-over">Account Key Roll-over</a></h1>
<p id="rfc.section.6.3.3.p.1">A client may wish to change the public key that is associated with a account in order to recover from a key compromise or proactively mitigate the impact of an unnoticed key compromise.</p>
<p id="rfc.section.6.3.3.p.2">To change the key associated with an account, the client first constructs a key-change object describing the change that it would like the server to make:</p>
<p/>

<dl>
  <dt>account (required, string):</dt>
  <dd style="margin-left: 8">The URL for account being modified.  The content of this field MUST be the exact string provided in the Location header field in response to the new-account request that created the account.</dd>
  <dt>newKey (required, JWK):</dt>
  <dd style="margin-left: 8">The JWK representation of the new key</dd>
</dl>
<p id="rfc.section.6.3.3.p.4">The client then encapsulates the key-change object in a JWS, signed with the requested new account key (i.e., the key matching the &#8220;newKey&#8221; value).</p>
<p id="rfc.section.6.3.3.p.5">The outer JWS MUST meet the normal requirements for an ACME JWS (see <a href="#request-authentication">Section 5.2</a>).  The inner JWS MUST meet the normal requirements, with the following exceptions:</p>
<p/>

<ul>
  <li>The inner JWS MUST have the same &#8220;url&#8221; parameter as the outer JWS.</li>
  <li>The inner JWS is NOT REQUIRED to have a &#8220;nonce&#8221; parameter.  The server MUST ignore any value provided for the &#8220;nonce&#8221; header parameter.</li>
</ul>
<p id="rfc.section.6.3.3.p.7">This transaction has signatures from both the old and new keys so that the server can verify that the holders of the two keys both agree to the change.  The signatures are nested to preserve the property that all signatures on POST messages are signed by exactly one key.</p>
<pre>
POST /acme/key-change HTTP/1.1
Host: example.com
Content-Type: application/jose+json

{
  "protected": base64url({
    "alg": "ES256",
    "jwk": /* old key */,
    "nonce": "K60BWPrMQG9SDxBDS_xtSw",
    "url": "https://example.com/acme/key-change"
  }),
  "payload": base64url({
    "protected": base64url({
      "alg": "ES256",
      "jwk": /* new key */,
      "url": "https://example.com/acme/key-change"
    }),
    "payload": base64url({
      "account": "https://example.com/acme/acct/1",
      "newKey": /* new key */
    }),
    "signature": "Xe8B94RD30Azj2ea...8BmZIRtcSKPSd8gU"
  }),
  "signature": "5TWiqIYQfIDfALQv...x9C2mg8JGPxl5bI4"
}
</pre>
<p id="rfc.section.6.3.3.p.8">On receiving key-change request, the server MUST perform the following steps in addition to the typical JWS validation:</p>
<p/>

<ol>
  <li>Validate the POST request belongs to a currently active account, as described in Message Transport.</li>
  <li>Check that the payload of the JWS is a well-formed JWS object (the &#8220;inner JWS&#8221;)</li>
  <li>Check that the JWS protected header of the inner JWS has a &#8220;jwk&#8221; field.</li>
  <li>Check that the inner JWS verifies using the key in its &#8220;jwk&#8221; field</li>
  <li>Check that the payload of the inner JWS is a well-formed key-change object (as described above)</li>
  <li>Check that the &#8220;url&#8221; parameters of the inner and outer JWSs are the same</li>
  <li>Check that the &#8220;account&#8221; field of the key-change object contains the URL for the account matching the old key</li>
  <li>Check that the &#8220;newKey&#8221; field of the key-change object contains the key used to sign the inner JWS.</li>
</ol>
<p id="rfc.section.6.3.3.p.10">If all of these checks pass, then the server updates the corresponding account by replacing the old account key with the new public key and returns status code 200. Otherwise, the server responds with an error status code and a problem document describing the error.</p>
<h1 id="rfc.section.6.3.4"><a href="#rfc.section.6.3.4">6.3.4.</a> <a href="#account-deactivation" id="account-deactivation">Account deactivation</a></h1>
<p id="rfc.section.6.3.4.p.1">A client can deactivate an account by posting a signed update to the server with a status field of &#8220;deactivated.&#8221; Clients may wish to do this when the account key is compromised or decommissioned.</p>
<pre>
POST /acme/acct/1 HTTP/1.1
Host: example.com
Content-Type: application/jose+json

{
  "protected": base64url({
    "alg": "ES256",
    "kid": "https://example.com/acme/acct/1",
    "nonce": "ntuJWWSic4WVNSqeUmshgg",
    "url": "https://example.com/acme/acct/1"
  }),
  "payload": base64url({
    "status": "deactivated"
  }),
  "signature": "earzVLd3m5M4xJzR...bVTqn7R08AKOVf3Y"
}
</pre>
<p id="rfc.section.6.3.4.p.2">The server MUST verify that the request is signed by the account key. If the server accepts the deactivation request, it replies with a 200 (OK) status code and the current contents of the account object.</p>
<p id="rfc.section.6.3.4.p.3">Once an account is deactivated, the server MUST NOT accept further requests authorized by that account&#8217;s key. It is up to server policy how long to retain data related to that account, whether to revoke certificates issued by that account, and whether to send email to that account&#8217;s contacts. ACME does not provide a way to reactivate a deactivated account.</p>
<h1 id="rfc.section.6.4"><a href="#rfc.section.6.4">6.4.</a> <a href="#applying-for-certificate-issuance" id="applying-for-certificate-issuance">Applying for Certificate Issuance</a></h1>
<p id="rfc.section.6.4.p.1">A client may use ACME to submit an order for a certificate to be issued.  The client makes this request by sending a POST request to the server&#8217;s new-order resource.  The body of the POST is a JWS object whose JSON payload is a subset of the order object defined in <a href="#order-objects">Section 6.1.3</a>, containing the fields that describe the certificate to be issued:</p>
<p/>

<dl>
  <dt>csr (required, string):</dt>
  <dd style="margin-left: 8">A CSR encoding the parameters for the certificate being requested <a href="#RFC2986">[RFC2986]</a>.  The CSR is sent in the base64url-encoded version of the DER format.  (Note: Because this field uses base64url, and does not include headers, it is different from PEM.)</dd>
  <dt>notBefore (optional, string):</dt>
  <dd style="margin-left: 8">The requested value of the notBefore field in the certificate, in the date format defined in <a href="#RFC3339">[RFC3339]</a></dd>
  <dt>notAfter (optional, string):</dt>
  <dd style="margin-left: 8">The requested value of the notAfter field in the certificate, in the date format defined in <a href="#RFC3339">[RFC3339]</a></dd>
</dl>
<pre>
POST /acme/new-order HTTP/1.1
Host: example.com
Content-Type: application/jose+json

{
  "protected": base64url({
    "alg": "ES256",
    "kid": "https://example.com/acme/acct/1",
    "nonce": "5XJ1L3lEkMG7tR6pA00clA",
    "url": "https://example.com/acme/new-order"
  }),
  "payload": base64url({
    "csr": "5jNudRx6Ye4HzKEqT5...FS6aKdZeGsysoCo4H9P",
    "notBefore": "2016-01-01T00:00:00Z",
    "notAfter": "2016-01-08T00:00:00Z"
  }),
  "signature": "H6ZXtGjTZyUnPeKn...wEA4TklBdh3e454g"
}
</pre>
<p id="rfc.section.6.4.p.3">The CSR encodes the client&#8217;s requests with regard to the content of the certificate to be issued.  The CSR MUST indicate the requested identifiers, either in the commonName portion of the requested subject name, or in an extensionRequest attribute <a href="#RFC2985">[RFC2985]</a> requesting a subjectAltName extension.</p>
<p id="rfc.section.6.4.p.4">The server MUST return an error if it cannot fulfill the request as specified, and MUST NOT issue a certificate with contents other than those requested.  If the server requires the request to be modified in a certain way, it should indicate the required changes using an appropriate error type and description.</p>
<p id="rfc.section.6.4.p.5">If the server is willing to issue the requested certificate, it responds with a 201 (Created) response.  The body of this response is an order object reflecting the client&#8217;s request and any authorizations the client must complete before the certificate will be issued.</p>
<pre>
HTTP/1.1 201 Created
Replay-Nonce: MYAuvOpaoIiywTezizk5vw
Location: https://example.com/acme/order/asdf

{
  "status": "pending",
  "expires": "2016-01-01T00:00:00Z",

  "csr": "jcRf4uXra7FGYW5ZMewvV...rhlnznwy8YbpMGqwidEXfE",
  "notBefore": "2016-01-01T00:00:00Z",
  "notAfter": "2016-01-08T00:00:00Z",

  "authorizations": [
    "https://example.com/acme/authz/1234",
    "https://example.com/acme/authz/2345"
  ]
}
</pre>
<p id="rfc.section.6.4.p.6">The order object returned by the server represents a promise that if the client fulfills the server&#8217;s requirements before the &#8220;expires&#8221; time, then the server will issue the requested certificate.  In the order object, any authorization referenced in the &#8220;authorizations&#8221; array whose status is &#8220;pending&#8221; represents an authorization transaction that the client must complete before the server will issue the certificate (see <a href="#identifier-authorization">Section 6.5</a>).  If the client fails to complete the required actions before the &#8220;expires&#8221; time, then the server SHOULD change the status of the order to &#8220;invalid&#8221; and MAY delete the order resource.</p>
<p id="rfc.section.6.4.p.7">The server MUST issue the requested certificate and update the order resource with a URL for the certificate shortly after the client has fulfilled the server&#8217;s requirements.   If the client has already satisfied the server&#8217;s requirements at the time of this request (e.g., by obtaining authorization for all of the identifiers in the certificate in previous transactions), then the server MUST proactively issue the requested certificate and provide a URL for it in the &#8220;certificate&#8221; field of the order.  The server MUST, however, still list the completed authorizations in the &#8220;authorizations&#8221; array.</p>
<p id="rfc.section.6.4.p.8">Once the client believes it has fulfilled the server&#8217;s requirements, it should send a GET request to the order resource to obtain its current state.  The status of the order will indicate what action the client should take:</p>
<p/>

<ul>
  <li>&#8220;invalid&#8221;: The certificate will not be issued.  Consider this order process abandoned.</li>
  <li>&#8220;pending&#8221;: The server does not believe that the client has fulfilled the requirements.  Check the &#8220;authorizations&#8221; array for entries that are still pending.</li>
  <li>&#8220;processing&#8221;: The server agrees that the requirements have been fulfilled, and is in the process of generating the certificate.  Retry after the time given in the &#8220;Retry-After&#8221; header field of the response, if any.</li>
  <li>&#8220;valid&#8221;: The server has issued the certificate and provisioned its URL to the &#8220;certificate&#8221; field of the order.  Download the certificate.</li>
</ul>
<h1 id="rfc.section.6.4.1"><a href="#rfc.section.6.4.1">6.4.1.</a> <a href="#pre-authorization" id="pre-authorization">Pre-Authorization</a></h1>
<p id="rfc.section.6.4.1.p.1">The order process described above presumes that authorization objects are created reactively, in response to a certificate order.  Some servers may also wish to enable clients to obtain authorization for an identifier proactively, outside of the context of a specific issuance.  For example, a client hosting virtual servers for a collection of names might wish to obtain authorization before any servers are created, and only create a certificate when a server starts up.</p>
<p id="rfc.section.6.4.1.p.2">In some cases, a CA running an ACME server might have a completely external, non-ACME process for authorizing a client to issue for an identifier.  In these case, the CA should provision its ACME server with authorization objects corresponding to these authorizations and reflect them as already valid in any orders submitted by the client.</p>
<p id="rfc.section.6.4.1.p.3">If a CA wishes to allow pre-authorization within ACME, it can offer a &#8220;new authorization&#8221; resource in its directory by adding the key &#8220;new-authz&#8221; with a URL for the new authorization resource.</p>
<p id="rfc.section.6.4.1.p.4">To request authorization for an identifier, the client sends a POST request to the new-authorization resource specifying the identifier for which authorization is being requested and how the server should behave with respect to existing authorizations for this identifier.</p>
<p/>

<dl>
  <dt>identifier (required, object):</dt>
  <dd style="margin-left: 8">The identifier that the account is authorized to represent: <dl><dt>type (required, string):</dt><dd style="margin-left: 8">The type of identifier.</dd><dt>value (required, string):</dt><dd style="margin-left: 8">The identifier itself.</dd></dl><p> </p></dd>
  <dt>existing (optional, string):</dt>
  <dd style="margin-left: 8">How an existing authorization should be handled. Possible values are &#8220;accept&#8221; and &#8220;require&#8221;.</dd>
</dl>
<pre>
POST /acme/new-authz HTTP/1.1
Host: example.com
Content-Type: application/jose+json

{
  "protected": base64url({
    "alg": "ES256",
    "jwk": {...},
    "nonce": "uQpSjlRb4vQVCjVYAyyUWg",
    "url": "https://example.com/acme/new-authz"
  }),
  "payload": base64url({
    "identifier": {
      "type": "dns",
      "value": "example.net"
    },
    "existing": "accept"
  }),
  "signature": "nuSDISbWG8mMgE7H...QyVUL68yzf3Zawps"
}
</pre>
<p id="rfc.section.6.4.1.p.6">Before processing the authorization request, the server SHOULD determine whether it is willing to issue certificates for the identifier.  For example, the server should check that the identifier is of a supported type.  Servers might also check names against a blacklist of known high-value identifiers.  If the server is unwilling to issue for the identifier, it SHOULD return a 403 (Forbidden) error, with a problem document describing the reason for the rejection.</p>
<p id="rfc.section.6.4.1.p.7">If the authorization request specifies &#8220;existing&#8221; with a value of &#8220;accept&#8221; or &#8220;require&#8221;, before proceeding, the server SHOULD determine whether there are any existing, valid authorization resources for the account and given identifier. If one or more such authorizations exists, a response SHOULD be returned with status code 303 (See Other) and a Location header pointing to the existing resource URL; processing of the request then stops. If there are multiple such authorizations, the authorization with the latest expiry date SHOULD be returned. If no existing authorizations were found and the value for &#8220;existing&#8221; was &#8220;require&#8221;, then the server MUST return status code 404 (Not Found); if it was &#8220;accept&#8221; or was any other value or was absent, processing continues as follows.</p>
<p id="rfc.section.6.4.1.p.8">If the server is willing to proceed, it builds a pending authorization object from the inputs submitted by the client.</p>
<p/>

<ul>
  <li>&#8220;identifier&#8221; the identifier submitted by the client</li>
  <li>&#8220;status&#8221; MUST be &#8220;pending&#8221; unless the server has out-of-band information about the client&#8217;s authorization status</li>
  <li>&#8220;challenges&#8221; and &#8220;combinations&#8221; as selected by the server&#8217;s policy for this identifier</li>
</ul>
<p id="rfc.section.6.4.1.p.10">The server allocates a new URI for this authorization, and returns a 201 (Created) response, with the authorization URI in a Location header field, and the JSON authorization object in the body.  The client then follows the process described in <a href="#identifier-authorization">Section 6.5</a> to complete the authorization process.</p>
<h1 id="rfc.section.6.4.2"><a href="#rfc.section.6.4.2">6.4.2.</a> <a href="#downloading-the-certificate" id="downloading-the-certificate">Downloading the Certificate</a></h1>
<p id="rfc.section.6.4.2.p.1">To download the issued certificate, the client simply sends a GET request to the certificate URL.</p>
<p id="rfc.section.6.4.2.p.2">The default format of the certificate is PEM (application/x-pem-file) as specified by <a href="#RFC7468">[RFC7468]</a>. This format should contain the end-entity certificate first, followed by any intermediate certificates that are needed to build a path to a trusted root. Servers SHOULD NOT include self-signed trust anchors. The client may request other formats by including an Accept header in its request.  For example, the client could use the media type <samp>application/pkix-cert</samp> <a href="#RFC2585">[RFC2585]</a> to request the end-entity certificate in DER format.</p>
<p id="rfc.section.6.4.2.p.3">The server MAY provide one or more link relation header fields <a href="#RFC5988">[RFC5988]</a> with relation &#8220;alternate&#8221;. Each such field should express an alternative certificate chain starting with the same end-entity certificate. This can be used to express paths to various trust anchors. Clients can fetch these alternates and use their own heuristics to decide which is optimal.</p>
<p id="rfc.section.6.4.2.p.4">The server MUST also provide a link relation header field with relation &#8220;author&#8221; to indicate the order under which this certificate was issued.</p>
<p id="rfc.section.6.4.2.p.5">If the CA participates in Certificate Transparency (CT) <a href="#RFC6962">[RFC6962]</a>, then they may want to provide the client with a Signed Certificate Timestamp (SCT) that can be used to prove that a certificate was submitted to a CT log.  An SCT can be included as an extension in the certificate or as an extension to OCSP responses for the certificate.  The server can also provide the client with direct access to an SCT for a certificate using a Link relation header field with relation &#8220;ct-sct&#8221;.</p>
<pre>
GET /acme/cert/asdf HTTP/1.1
Host: example.com
Accept: application/pkix-cert

HTTP/1.1 200 OK
Content-Type: application/pkix-cert
Link: &lt;https://example.com/acme/ca-cert&gt;;rel="up";title="issuer"
Link: &lt;https://example.com/acme/revoke-cert&gt;;rel="revoke"
Link: &lt;https://example.com/acme/order/asdf&gt;;rel="author"
Link: &lt;https://example.com/acme/sct/asdf&gt;;rel="ct-sct"
Link: &lt;https://example.com/acme/some-directory&gt;;rel="directory"

-----BEGIN CERTIFICATE-----
[End-entity certificate contents]
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
[Issuer certificate contents]
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
[Other certificate contents]
-----END CERTIFICATE-----
</pre>
<p id="rfc.section.6.4.2.p.6">A certificate resource represents a single, immutable certificate. If the client wishes to obtain a renewed certificate, the client initiates a new order process to request one.</p>
<p id="rfc.section.6.4.2.p.7">Because certificate resources are immutable once issuance is complete, the server MAY enable the caching of the resource by adding Expires and Cache-Control headers specifying a point in time in the distant future. These headers have no relation to the certificate&#8217;s period of validity.</p>
<h1 id="rfc.section.6.5"><a href="#rfc.section.6.5">6.5.</a> <a href="#identifier-authorization" id="identifier-authorization">Identifier Authorization</a></h1>
<p id="rfc.section.6.5.p.1">The identifier authorization process establishes the authorization of an account to manage certificates for a given identifier.  This process assures the server of two things:</p>
<p/>

<ol>
  <li>That the client controls the private key of the account key pair, and</li>
  <li>That the client controls the identifier in question.</li>
</ol>
<p id="rfc.section.6.5.p.3">This process may be repeated to associate multiple identifiers to a key pair (e.g., to request certificates with multiple identifiers), or to associate multiple accounts with an identifier (e.g., to allow multiple entities to manage certificates).  The server may declare that an authorization is only valid for a specific order by setting the &#8220;scope&#8221; field of the authorization to the URI for that order.</p>
<p id="rfc.section.6.5.p.4">Authorization resources are created by the server in response to certificate orders or authorization requests submitted by an account key holder; their URLs are provided to the client in the responses to these requests.  The authorization object is implicitly tied to the account key used to sign the request.</p>
<p id="rfc.section.6.5.p.5">When a client receives an order from the server it downloads the authorization resource by sending a GET request to the indicated URL.  If the client initiates authorization using a request to the new authorization resource, it will have already received the pending authorization object in the response to that request.</p>
<pre>
GET /acme/authz/1234 HTTP/1.1
Host: example.com

HTTP/1.1 200 OK
Content-Type: application/json
Link: &lt;https://example.com/acme/some-directory&gt;;rel="directory"

{
  "status": "pending",
  "expires": "2018-03-03T14:09:00Z",

  "identifier": {
    "type": "dns",
    "value": "example.org"
  },

  "challenges": [
    {
      "type": "http-01",
      "url": "https://example.com/authz/1234/0",
      "token": "DGyRejmCefe7v4NfDGDKfA"
    },
    {
      "type": "tls-sni-02",
      "url": "https://example.com/authz/1234/1",
      "token": "DGyRejmCefe7v4NfDGDKfA"
    },
    {
      "type": "dns-01",
      "url": "https://example.com/authz/1234/2",
      "token": "DGyRejmCefe7v4NfDGDKfA"
    }
  ]
}
</pre>
<h1 id="rfc.section.6.5.1"><a href="#rfc.section.6.5.1">6.5.1.</a> <a href="#responding-to-challenges" id="responding-to-challenges">Responding to Challenges</a></h1>
<p id="rfc.section.6.5.1.p.1">To prove control of the identifier and receive authorization, the client needs to respond with information to complete the challenges.  To do this, the client updates the authorization object received from the server by filling in any required information in the elements of the &#8220;challenges&#8221; dictionary.  (This is also the stage where the client should perform any actions required by the challenge.)</p>
<p id="rfc.section.6.5.1.p.2">The client sends these updates back to the server in the form of a JSON object with the response fields required by the challenge type, carried in a POST request to the challenge URI (not authorization URI).  This allows the client to send information only for challenges it is responding to.</p>
<p id="rfc.section.6.5.1.p.3">For example, if the client were to respond to the &#8220;http-01&#8221; challenge in the above authorization, it would send the following request:</p>
<pre>
POST /acme/authz/asdf/0 HTTP/1.1
Host: example.com
Content-Type: application/jose+json

{
  "protected": base64url({
    "alg": "ES256",
    "kid": "https://example.com/acme/acct/1",
    "nonce": "Q_s3MWoqT05TrdkM2MTDcw",
    "url": "https://example.com/acme/authz/asdf/0"
  }),
  "payload": base64url({
    "type": "http-01",
    "keyAuthorization": "IlirfxKKXA...vb29HhjjLPSggwiE"
  }),
  "signature": "9cbg5JO1Gf5YLjjz...SpkUfcdPai9uVYYQ"
}
</pre>
<p id="rfc.section.6.5.1.p.4">The server updates the authorization document by updating its representation of the challenge with the response fields provided by the client.  The server MUST ignore any fields in the response object that are not specified as response fields for this type of challenge.  The server provides a 200 (OK) response with the updated challenge object as its body.</p>
<p id="rfc.section.6.5.1.p.5">If the client&#8217;s response is invalid for any reason, or does not provide the server with appropriate information to validate the challenge, then the server MUST return an HTTP error.  On receiving such an error, the client SHOULD undo any actions that have been taken to fulfill the challenge, e.g., removing files that have been provisioned to a web server.</p>
<p id="rfc.section.6.5.1.p.6">The server is said to &#8220;finalize&#8221; the authorization when it has completed one of the validations, by assigning the authorization a status of &#8220;valid&#8221; or &#8220;invalid&#8221;, corresponding to whether it considers the account authorized for the identifier. If the final state is &#8220;valid&#8221;, then the server MUST include an &#8220;expires&#8221; field. When finalizing an authorization, the server MAY remove challenges other than the one that was completed, and may modify the &#8220;expires&#8221; field. The server SHOULD NOT remove challenges with status &#8220;invalid&#8221;.</p>
<p id="rfc.section.6.5.1.p.7">Usually, the validation process will take some time, so the client will need to poll the authorization resource to see when it is finalized.  For challenges where the client can tell when the server has validated the challenge (e.g., by seeing an HTTP or DNS request from the server), the client SHOULD NOT begin polling until it has seen the validation request from the server.</p>
<p id="rfc.section.6.5.1.p.8">To check on the status of an authorization, the client sends a GET request to the authorization URI, and the server responds with the current  authorization object. In responding to poll requests while the validation is still in progress, the server MUST return a 202 (Accepted) response, and MAY include a Retry-After header field to suggest a polling interval to the client.</p>
<pre>
GET /acme/authz/asdf HTTP/1.1
Host: example.com

HTTP/1.1 200 OK

{
  "status": "valid",
  "expires": "2018-09-09T14:09:00Z",

  "identifier": {
    "type": "dns",
    "value": "example.org"
  },

  "challenges": [
    {
      "type": "http-01"
      "url": "https://example.com/authz/asdf/0",
      "status": "valid",
      "validated": "2014-12-01T12:05:00Z",
      "token": "IlirfxKKXAsHtmzK29Pj8A",
      "keyAuthorization": "IlirfxKKXA...vb29HhjjLPSggwiE"
    }
  ]
}
</pre>
<h1 id="rfc.section.6.5.2"><a href="#rfc.section.6.5.2">6.5.2.</a> <a href="#deactivating-an-authorization" id="deactivating-an-authorization">Deactivating an Authorization</a></h1>
<p id="rfc.section.6.5.2.p.1">If a client wishes to relinquish its authorization to issue certificates for an identifier, then it may request that the server deactivate each authorization associated with that identifier by sending a POST request with the static object {&#8220;status&#8221;: &#8220;deactivated&#8221;}.</p>
<pre>
POST /acme/authz/asdf HTTP/1.1
Host: example.com
Content-Type: application/jose+json

{
  "protected": base64url({
    "alg": "ES256",
    "kid": "https://example.com/acme/acct/1",
    "nonce": "xWCM9lGbIyCgue8di6ueWQ",
    "url": "https://example.com/acme/authz/asdf"
  }),
  "payload": base64url({
    "status": "deactivated"
  }),
  "signature": "srX9Ji7Le9bjszhu...WTFdtujObzMtZcx4"
}
</pre>
<p id="rfc.section.6.5.2.p.2">The server MUST verify that the request is signed by the account key corresponding to the account that owns the authorization. If the server accepts the deactivation, it should reply with a 200 (OK) status code and the current contents of the authorization object.</p>
<p id="rfc.section.6.5.2.p.3">The server MUST NOT treat deactivated authorization objects as sufficient for issuing certificates.</p>
<h1 id="rfc.section.6.6"><a href="#rfc.section.6.6">6.6.</a> <a href="#certificate-revocation" id="certificate-revocation">Certificate Revocation</a></h1>
<p id="rfc.section.6.6.p.1">To request that a certificate be revoked, the client sends a POST request to the ACME server&#8217;s revoke-cert URI.  The body of the POST is a JWS object whose JSON payload contains the certificate to be revoked:</p>
<p/>

<dl>
  <dt>certificate (required, string):</dt>
  <dd style="margin-left: 8">The certificate to be revoked, in the base64url-encoded version of the DER format.  (Note: Because this field uses base64url, and does not include headers, it is different from PEM.)</dd>
  <dt>reason (optional, int):</dt>
  <dd style="margin-left: 8">One of the revocation reasonCodes defined in Section 5.3.1 of <a href="#RFC5280">[RFC5280]</a> to be used when generating OCSP responses and CRLs. If this field is not set the server SHOULD use the unspecified (0) reasonCode value when generating OCSP responses and CRLs. The server MAY disallow a subset of reasonCodes from being used by the user.</dd>
</dl>
<pre>
POST /acme/revoke-cert HTTP/1.1
Host: example.com
Content-Type: application/jose+json

{
  "protected": base64url({
    "alg": "ES256",
    "kid": "https://example.com/acme/acct/1", // OR "jwk"
    "nonce": "JHb54aT_KTXBWQOzGYkt9A",
    "url": "https://example.com/acme/revoke-cert"
  }),
  "payload": base64url({
    "certificate": "MIIEDTCCAvegAwIBAgIRAP8...",
    "reason": 1
  }),
  "signature": "Q1bURgJoEslbD1c5...3pYdSMLio57mQNN4"
}
</pre>
<p id="rfc.section.6.6.p.3">Revocation requests are different from other ACME request in that they can be signed either with an account key pair or the key pair in the certificate.  Before revoking a certificate, the server MUST verify that the key used to sign the request is authorized to revoke the certificate.  The server SHOULD consider at least the following accounts authorized for a given certificate:</p>
<p/>

<ul>
  <li>the account that issued the certificate.</li>
  <li>an account that holds authorizations for all of the identifiers in the certificate.</li>
</ul>
<p id="rfc.section.6.6.p.5">The server SHOULD also consider a revocation request valid if it is signed with the private key corresponding to the public key in the certificate.</p>
<p id="rfc.section.6.6.p.6">If the revocation succeeds, the server responds with status code 200 (OK).  If the revocation fails, the server returns an error.</p>
<pre>
HTTP/1.1 200 OK
Replay-Nonce: IXVHDyxIRGcTE0VSblhPzw
Content-Length: 0

--- or ---

HTTP/1.1 403 Forbidden
Replay-Nonce: IXVHDyxIRGcTE0VSblhPzw
Content-Type: application/problem+json
Content-Language: en

{
  "type": "urn:ietf:params:acme:error:unauthorized",
  "detail": "No authorization provided for name example.net",
  "instance": "http://example.com/doc/unauthorized"
}
</pre>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#identifier-validation-challenges" id="identifier-validation-challenges">Identifier Validation Challenges</a></h1>
<p id="rfc.section.7.p.1">There are few types of identifiers in the world for which there is a standardized mechanism to prove possession of a given identifier.  In all practical cases, CAs rely on a variety of means to test whether an entity applying for a certificate with a given identifier actually controls that identifier.</p>
<p id="rfc.section.7.p.2">Challenges provide the server with assurance that an account holder is also the entity that controls an identifier.  For each type of challenge, it must be the case that in order for an entity to successfully complete the challenge the entity must both:</p>
<p/>

<ul>
  <li>Hold the private key of the account key pair used to respond to the challenge</li>
  <li>Control the identifier in question</li>
</ul>
<p><a href="#security-considerations">Section 9</a> documents how the challenges defined in this document meet these requirements.  New challenges will need to document how they do.</p>
<p id="rfc.section.7.p.5">ACME uses an extensible challenge/response framework for identifier validation.  The server presents a set of challenges in the authorization object it sends to a client (as objects in the &#8220;challenges&#8221; array), and the client responds by sending a response object in a POST request to a challenge URI.</p>
<p id="rfc.section.7.p.6">This section describes an initial set of challenge types.  Each challenge must describe:</p>
<p/>

<ol>
  <li>Content of challenge objects</li>
  <li>Content of response objects</li>
  <li>How the server uses the challenge and response to verify control of an identifier</li>
</ol>
<p id="rfc.section.7.p.8">Challenge objects all contain the following basic fields:</p>
<p/>

<dl>
  <dt>type (required, string):</dt>
  <dd style="margin-left: 8">The type of challenge encoded in the object.</dd>
  <dt>url (required, string):</dt>
  <dd style="margin-left: 8">The URL to which a response can be posted.</dd>
  <dt>status (required, string):</dt>
  <dd style="margin-left: 8">The status of this authorization.  Possible values are: &#8220;pending&#8221;, &#8220;valid&#8221;, and &#8220;invalid&#8221;.</dd>
  <dt>validated (optional, string):</dt>
  <dd style="margin-left: 8">The time at which this challenge was completed by the server, encoded in the format specified in RFC 3339 <a href="#RFC3339">[RFC3339]</a>.  This field is REQUIRED if the &#8220;status&#8221; field is &#8220;valid&#8221;.</dd>
  <dt>error (optional, object):</dt>
  <dd style="margin-left: 8">The error that occurred while the server was validating the challenge, if any.  This field is structured as a problem document <a href="#RFC7807">[RFC7807]</a>.</dd>
</dl>
<p id="rfc.section.7.p.10">All additional fields are specified by the challenge type.  If the server sets a challenge&#8217;s &#8220;status&#8221; to &#8220;invalid&#8221;, it SHOULD also include the &#8220;error&#8221; field to help the client diagnose why they failed the challenge.</p>
<p id="rfc.section.7.p.11">Different challenges allow the server to obtain proof of different aspects of control over an identifier.  In some challenges, like HTTP, TLS SNI, and DNS, the client directly proves its ability to do certain things related to the identifier.  The choice of which challenges to offer to a client under which circumstances is a matter of server policy.</p>
<p id="rfc.section.7.p.12">The identifier validation challenges described in this section all relate to validation of domain names.  If ACME is extended in the future to support other types of identifier, there will need to be new challenge types, and they will need to specify which types of identifier they apply to.</p>
<p id="rfc.section.7.p.13">[[ Editor&#8217;s Note: In pre-RFC versions of this specification, challenges are labeled by type, and with the version of the draft in which they were introduced.  For example, if an HTTP challenge were introduced in version -03 and a breaking change made in version -05, then there would be a challenge labeled &#8220;http-03&#8221; and one labeled &#8220;http-05&#8221; &#8211; but not one labeled &#8220;http-04&#8221;, since challenge in version -04 was compatible with one in version -04. ]]</p>
<h1 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1.</a> <a href="#key-authorizations" id="key-authorizations">Key Authorizations</a></h1>
<p id="rfc.section.7.1.p.1">Several of the challenges in this document makes use of a key authorization string.  A key authorization is a string that expresses a domain holder&#8217;s authorization for a specified key to satisfy a specified challenge, by concatenating the token for the challenge with a key fingerprint, separated by a &#8220;.&#8221; character:</p>
<pre>
key-authz = token || '.' || base64url(JWK_Thumbprint(accountKey))
</pre>
<p id="rfc.section.7.1.p.2">The &#8220;JWK_Thumbprint&#8221; step indicates the computation specified in <a href="#RFC7638">[RFC7638]</a>, using the SHA-256 digest <a href="#FIPS180-4">[FIPS180-4]</a>.  As specified in the individual challenges below, the token for a challenge is a JSON string comprised entirely of characters in the URL-safe base64 alphabet.  The &#8220;||&#8221; operator indicates concatenation of strings.</p>
<p id="rfc.section.7.1.p.3">In computations involving key authorizations, such as the digest computations required for the DNS and TLS SNI challenges, the key authorization string MUST be represented in UTF-8 form (or, equivalently, ASCII).</p>
<p id="rfc.section.7.1.p.4">An example of how to compute a JWK thumbprint can be found in Section 3.1 of <a href="#RFC7638">[RFC7638]</a>.  Note that some cryptographic libraries prepend a zero octet to the representation of the RSA public key parameters N and E, in order to avoid ambiguity with regard to the sign of the number.  As noted in JWA <a href="#RFC7518">[RFC7518]</a>, a JWK object MUST NOT include this zero octet.  That is, any initial zero octets MUST be stripped before the values are base64url-encoded.</p>
<h1 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2.</a> <a href="#http" id="http">HTTP</a></h1>
<p id="rfc.section.7.2.p.1">With HTTP validation, the client in an ACME transaction proves its control over a domain name by proving that it can provision resources on an HTTP server that responds for that domain name.  The ACME server challenges the client to provision a file at a specific path, with a specific string as its content.</p>
<p id="rfc.section.7.2.p.2">As a domain may resolve to multiple IPv4 and IPv6 addresses, the server will connect to at least one of the hosts found in the DNS A and AAAA records, at its discretion.  Because many webservers allocate a default HTTPS virtual host to a particular low-privilege tenant user in a subtle and non-intuitive manner, the challenge must be completed over HTTP, not HTTPS.</p>
<p/>

<dl>
  <dt>type (required, string):</dt>
  <dd style="margin-left: 8">The string &#8220;http-01&#8221;</dd>
  <dt>token (required, string):</dt>
  <dd style="margin-left: 8">A random value that uniquely identifies the challenge.  This value MUST have at least 128 bits of entropy, in order to prevent an attacker from guessing it.  It MUST NOT contain any characters outside the base64url alphabet, including padding characters (&#8220;=&#8221;).</dd>
</dl>
<pre>
GET /acme/authz/1234/0 HTTP/1.1
Host: example.com

HTTP/1.1 200 OK
{
  "type": "http-01",
  "url": "https://example.com/acme/authz/0",
  "status": "pending",
  "token": "evaGxfADs6pSRb2LAv9IZf17"
}
</pre>
<p id="rfc.section.7.2.p.4">A client responds to this challenge by constructing a key authorization from the &#8220;token&#8221; value provided in the challenge and the client&#8217;s account key.  The client then provisions the key authorization as a resource on the HTTP server for the domain in question.</p>
<p id="rfc.section.7.2.p.5">The path at which the resource is provisioned is comprised of the fixed prefix &#8220;.well-known/acme-challenge/&#8221;, followed by the &#8220;token&#8221; value in the challenge.  The value of the resource MUST be the ASCII representation of the key authorization.</p>
<pre>
.well-known/acme-challenge/evaGxfADs6pSRb2LAv9IZf17
</pre>
<p id="rfc.section.7.2.p.6">The client&#8217;s response to this challenge indicates its agreement to this challenge by sending the server the key authorization covering the challenge&#8217;s token and the client&#8217;s account key.</p>
<p/>

<dl>
  <dt>keyAuthorization (required, string):</dt>
  <dd style="margin-left: 8">The key authorization for this challenge.  This value MUST match the token from the challenge and the client&#8217;s account key.</dd>
</dl>
<pre>
POST /acme/authz/1234/0
Host: example.com
Content-Type: application/jose+json

{
  "protected": base64url({
    "alg": "ES256",
    "kid": "https://example.com/acme/acct/1",
    "nonce": "JHb54aT_KTXBWQOzGYkt9A",
    "url": "https://example.com/acme/authz/1234/0"
  }),
  "payload": base64url({
    "keyAuthorization": "evaGxfADs...62jcerQ"
  }),
  "signature": "Q1bURgJoEslbD1c5...3pYdSMLio57mQNN4"
}
</pre>
<p id="rfc.section.7.2.p.8">On receiving a response, the server MUST verify that the key authorization in the response matches the &#8220;token&#8221; value in the challenge and the client&#8217;s account key.  If they do not match, then the server MUST return an HTTP error in response to the POST request in which the client sent the challenge.</p>
<p id="rfc.section.7.2.p.9">Given a challenge/response pair, the server verifies the client&#8217;s control of the domain by verifying that the resource was provisioned as expected.</p>
<p/>

<ol>
  <li>Form a URI by populating the URI template <a href="#RFC6570">[RFC6570]</a> &#8220;http://{domain}/.well-known/acme-challenge/{token}&#8221;, where: <ul><li>the domain field is set to the domain name being verified; and</li><li>the token field is set to the token in the challenge.</li></ul></li>
  <li>Verify that the resulting URI is well-formed.</li>
  <li>Dereference the URI using an HTTP GET request.  This request MUST be sent to TCP port 80 on the server.</li>
  <li>Verify that the body of the response is well-formed key authorization.  The server SHOULD ignore whitespace characters at the end of the body.</li>
  <li>Verify that key authorization provided by the server matches the token for this challenge and the client&#8217;s account key.</li>
</ol>
<p id="rfc.section.7.2.p.11">If all of the above verifications succeed, then the validation is successful.  If the request fails, or the body does not pass these checks, then it has failed.</p>
<h1 id="rfc.section.7.3"><a href="#rfc.section.7.3">7.3.</a> <a href="#tls-with-server-name-indication-tls-sni" id="tls-with-server-name-indication-tls-sni">TLS with Server Name Indication (TLS SNI)</a></h1>
<p id="rfc.section.7.3.p.1">The TLS with Server Name Indication (TLS SNI) validation method proves control over a domain name by requiring the client to configure a TLS server referenced by the DNS A and AAAA resource records under the domain name to respond to specific connection attempts utilizing the Server Name Indication extension <a href="#RFC6066">[RFC6066]</a>. The server verifies the client&#8217;s challenge by accessing the reconfigured server and verifying a particular challenge certificate is presented.</p>
<p/>

<dl>
  <dt>type (required, string):</dt>
  <dd style="margin-left: 8">The string &#8220;tls-sni-02&#8221;</dd>
  <dt>token (required, string):</dt>
  <dd style="margin-left: 8">A random value that uniquely identifies the challenge.  This value MUST have at least 128 bits of entropy, in order to prevent an attacker from guessing it.  It MUST NOT contain any characters outside the base64url alphabet, including padding characters (&#8220;=&#8221;).</dd>
</dl>
<pre>
GET /acme/authz/1234/1 HTTP/1.1
Host: example.com

HTTP/1.1 200 OK
{
  "type": "tls-sni-02",
  "url": "https://example.com/acme/authz/1234/1",
  "status": "pending",
  "token": "evaGxfADs6pSRb2LAv9IZf17Dt3juxGJ-PCt92wr-oA"
}
</pre>
<p id="rfc.section.7.3.p.3">A client responds to this challenge by constructing a self-signed certificate which the client MUST provision at the domain name concerned in order to pass the challenge.</p>
<p id="rfc.section.7.3.p.4">The certificate may be constructed arbitrarily, except that each certificate MUST have exactly two subjectAlternativeNames, SAN A and SAN B. Both MUST be dNSNames.</p>
<p id="rfc.section.7.3.p.5">SAN A MUST be constructed as follows: compute the SHA-256 digest <a href="#FIPS180-4">[FIPS180-4]</a> of the UTF-8-encoded challenge token and encode it in lowercase hexadecimal form.  The dNSName is &#8220;x.y.token.acme.invalid&#8221;, where x is the first half of the hexadecimal representation and y is the second half.</p>
<p id="rfc.section.7.3.p.6">SAN B MUST be constructed as follows: compute the SHA-256 digest of the UTF-8 encoded key authorization and encode it in lowercase hexadecimal form. The dNSName is &#8220;x.y.ka.acme.invalid&#8221; where x is the first half of the hexadecimal representation and y is the second half.</p>
<p id="rfc.section.7.3.p.7">The client MUST ensure that the certificate is served to TLS connections specifying a Server Name Indication (SNI) value of SAN A.</p>
<p id="rfc.section.7.3.p.8">The response to the TLS-SNI challenge simply acknowledges that the client is ready to fulfill this challenge.</p>
<p/>

<dl>
  <dt>keyAuthorization (required, string):</dt>
  <dd style="margin-left: 8">The key authorization for this challenge.  This value MUST match the token from the challenge and the client&#8217;s account key.</dd>
</dl>
<pre>
POST /acme/authz/1234/1
Host: example.com
Content-Type: application/jose+json

{
  "protected": base64url({
    "alg": "ES256",
    "kid": "https://example.com/acme/acct/1",
    "nonce": "JHb54aT_KTXBWQOzGYkt9A",
    "url": "https://example.com/acme/authz/1234/1"
  }),
  "payload": base64url({
    "keyAuthorization": "evaGxfADs...62jcerQ"
  }),
  "signature": "Q1bURgJoEslbD1c5...3pYdSMLio57mQNN4"
}
</pre>
<p id="rfc.section.7.3.p.10">On receiving a response, the server MUST verify that the key authorization in the response matches the &#8220;token&#8221; value in the challenge and the client&#8217;s account key.  If they do not match, then the server MUST return an HTTP error in response to the POST request in which the client sent the challenge.</p>
<p id="rfc.section.7.3.p.11">Given a challenge/response pair, the ACME server verifies the client&#8217;s control of the domain by verifying that the TLS server was configured appropriately, using these steps:</p>
<p/>

<ol>
  <li>Compute SAN A and SAN B in the same way as the client.</li>
  <li>Open a TLS connection to the domain name being validated, presenting SAN A in the SNI field. This connection MUST be sent to TCP port 443 on the server. In the ClientHello initiating the TLS handshake, the server MUST include a server_name extension (i.e., SNI) containing SAN A. The server SHOULD ensure that it does not reveal SAN B in any way when making the TLS connection, such that the presentation of SAN B in the returned certificate proves association with the client.</li>
  <li>Verify that the certificate contains a subjectAltName extension containing dNSName entries of SAN A and SAN B and no other entries.  The comparison MUST be insensitive to case and ordering of names.</li>
</ol>
<p id="rfc.section.7.3.p.13">It is RECOMMENDED that the server open multiple TLS connections from various network perspectives, in order to make MitM attacks harder.</p>
<p id="rfc.section.7.3.p.14">If all of the above verifications succeed, then the validation is successful.  Otherwise, the validation fails.</p>
<h1 id="rfc.section.7.4"><a href="#rfc.section.7.4">7.4.</a> <a href="#dns" id="dns">DNS</a></h1>
<p id="rfc.section.7.4.p.1">When the identifier being validated is a domain name, the client can prove control of that domain by provisioning a resource record under it.   The DNS challenge requires the client to provision a TXT record containing a designated value under a specific validation domain name.</p>
<p/>

<dl>
  <dt>type (required, string):</dt>
  <dd style="margin-left: 8">The string &#8220;dns-01&#8221;</dd>
  <dt>token (required, string):</dt>
  <dd style="margin-left: 8">A random value that uniquely identifies the challenge.  This value MUST have at least 128 bits of entropy, in order to prevent an attacker from guessing it.  It MUST NOT contain any characters outside the base64url alphabet, including padding characters (&#8220;=&#8221;).</dd>
</dl>
<pre>
GET /acme/authz/1234/2 HTTP/1.1
Host: example.com

HTTP/1.1 200 OK
{
  "type": "dns-01",
  "url": "https://example.com/acme/authz/1234/2",
  "status": "pending",
  "token": "evaGxfADs6pSRb2LAv9IZf17Dt3juxGJ-PCt92wr-oA"
}
</pre>
<p id="rfc.section.7.4.p.3">A client responds to this challenge by constructing a key authorization from the &#8220;token&#8221; value provided in the challenge and the client&#8217;s account key.  The client then computes the SHA-256 digest <a href="#FIPS180-4">[FIPS180-4]</a> of the key authorization.</p>
<p id="rfc.section.7.4.p.4">The record provisioned to the DNS is the base64url encoding of this digest.  The client constructs the validation domain name by prepending the label &#8220;_acme-challenge&#8221; to the domain name being validated, then provisions a TXT record with the digest value under that name. For example, if the domain name being validated is &#8220;example.com&#8221;, then the client would provision the following DNS record:</p>
<pre>
_acme-challenge.example.com. 300 IN TXT "gfj9Xq...Rg85nM"
</pre>
<p id="rfc.section.7.4.p.5">The response to the DNS challenge provides the computed key authorization to acknowledge that the client is ready to fulfill this challenge.</p>
<p/>

<dl>
  <dt>keyAuthorization (required, string):</dt>
  <dd style="margin-left: 8">The key authorization for this challenge.  This value MUST match the token from the challenge and the client&#8217;s account key.</dd>
</dl>
<pre>
POST /acme/authz/1234/2
Host: example.com
Content-Type: application/jose+json

{
  "protected": base64url({
    "alg": "ES256",
    "kid": "https://example.com/acme/acct/1",
    "nonce": "JHb54aT_KTXBWQOzGYkt9A",
    "url": "https://example.com/acme/authz/1234/2"
  }),
  "payload": base64url({
    "keyAuthorization": "evaGxfADs...62jcerQ"
  }),
  "signature": "Q1bURgJoEslbD1c5...3pYdSMLio57mQNN4"
}
</pre>
<p id="rfc.section.7.4.p.7">On receiving a response, the server MUST verify that the key authorization in the response matches the &#8220;token&#8221; value in the challenge and the client&#8217;s account key.  If they do not match, then the server MUST return an HTTP error in response to the POST request in which the client sent the challenge.</p>
<p id="rfc.section.7.4.p.8">To validate a DNS challenge, the server performs the following steps:</p>
<p/>

<ol>
  <li>Compute the SHA-256 digest <a href="#FIPS180-4">[FIPS180-4]</a> of the key authorization</li>
  <li>Query for TXT records under the validation domain name</li>
  <li>Verify that the contents of one of the TXT records matches the digest value</li>
</ol>
<p id="rfc.section.7.4.p.10">It is RECOMMENDED that the server perform multiple DNS queries from various network perspectives, in order to make MitM attacks harder.</p>
<p id="rfc.section.7.4.p.11">If all of the above verifications succeed, then the validation is successful.  If no DNS record is found, or DNS record and response payload do not pass these checks, then the validation fails.</p>
<h1 id="rfc.section.7.5"><a href="#rfc.section.7.5">7.5.</a> <a href="#out-of-band" id="out-of-band">Out-of-Band</a></h1>
<p id="rfc.section.7.5.p.1">There may be cases where a server cannot perform automated validation of an identifier, for example if validation requires some manual steps.  In such cases, the server may provide an &#8220;out of band&#8221; (OOB) challenge to request that the client perform some action outside of ACME in order to validate possession of the identifier.</p>
<p id="rfc.section.7.5.p.2">The OOB challenge requests that the client have a human user visit a web page to receive instructions on how to validate possession of the identifier, by providing a URL for that web page.</p>
<p/>

<dl>
  <dt>type (required, string):</dt>
  <dd style="margin-left: 8">The string &#8220;oob-01&#8221;</dd>
  <dt>href (required, string):</dt>
  <dd style="margin-left: 8">The URL to be visited.  The scheme of this URL MUST be &#8220;http&#8221; or &#8220;https&#8221;.  Note that this field is distinct from the &#8220;url&#8221; field of the challenge, which identifies the challenge itself.</dd>
</dl>
<pre>
GET /acme/authz/1234/3 HTTP/1.1
Host: example.com

HTTP/1.1 200 OK
{
  "type": "oob-01",
  "href": "https://example.com/validate/evaGxfADs6pSRb2LAv9IZ"
}
</pre>
<p id="rfc.section.7.5.p.4">A client responds to this challenge by presenting the indicated URL for a human user to navigate to.  If the user chooses to complete this challenge (by visiting the website and completing its instructions), the client indicates this by sending a simple acknowledgement response to the server.</p>
<p/>

<dl>
  <dt>type (required, string):</dt>
  <dd style="margin-left: 8">The string &#8220;oob-01&#8221;</dd>
</dl>
<pre>
POST /acme/authz/1234/3
Host: example.com
Content-Type: application/jose+json

{
  "protected": base64url({
    "alg": "ES256",
    "kid": "https://example.com/acme/acct/1",
    "nonce": "JHb54aT_KTXBWQOzGYkt9A",
    "url": "https://example.com/acme/authz/1234/3"
  }),
  "payload": base64url({
    "type": "oob-01"
  }),
  "signature": "Q1bURgJoEslbD1c5...3pYdSMLio57mQNN4"
}
</pre>
<p id="rfc.section.7.5.p.6">On receiving a response, the server MUST verify that the value of the &#8220;type&#8221; field is &#8220;oob-01&#8221;.  Otherwise, the steps the server takes to validate identifier possession are determined by the server&#8217;s local policy.</p>
<h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a></h1>
<h1 id="rfc.section.8.1"><a href="#rfc.section.8.1">8.1.</a> <a href="#well-known-uri-for-the-http-challenge" id="well-known-uri-for-the-http-challenge">Well-Known URI for the HTTP Challenge</a></h1>
<p id="rfc.section.8.1.p.1">The &#8220;Well-Known URIs&#8221; registry should be updated with the following additional value (using the template from <a href="#RFC5785">[RFC5785]</a>):</p>
<p id="rfc.section.8.1.p.2">URI suffix: acme-challenge</p>
<p id="rfc.section.8.1.p.3">Change controller: IETF</p>
<p id="rfc.section.8.1.p.4">Specification document(s): This document, Section <a href="#http">Section 7.2</a></p>
<p id="rfc.section.8.1.p.5">Related information: N/A</p>
<h1 id="rfc.section.8.2"><a href="#rfc.section.8.2">8.2.</a> <a href="#replay-nonce-http-header" id="replay-nonce-http-header">Replay-Nonce HTTP Header</a></h1>
<p id="rfc.section.8.2.p.1">The &#8220;Message Headers&#8221; registry should be updated with the following additional value:</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="left">Header Field Name</th>
      <th class="left">Protocol</th>
      <th class="left">Status</th>
      <th class="left">Reference</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">Replay-Nonce</td>
      <td class="left">http</td>
      <td class="left">standard</td>
      <td class="left">
        <a href="#replay-nonce">Section 5.5.1</a>
      </td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.section.8.3"><a href="#rfc.section.8.3">8.3.</a> <a href="#url-jws-header-parameter" id="url-jws-header-parameter">&#8220;url&#8221; JWS Header Parameter</a></h1>
<p id="rfc.section.8.3.p.1">The &#8220;JSON Web Signature and Encryption Header Parameters&#8221; registry should be updated with the following additional value:</p>
<p/>

<ul>
  <li>Header Parameter Name: &#8220;url&#8221;</li>
  <li>Header Parameter Description: URL</li>
  <li>Header Parameter Usage Location(s): JWE, JWS</li>
  <li>Change Controller: IESG</li>
  <li>Specification Document(s): <a href="#url-url-jws-header-parameter">Section 5.4.1</a> of RFC XXXX</li>
</ul>
<p id="rfc.section.8.3.p.3">[[ RFC EDITOR: Please replace XXXX above with the RFC number assigned to this document ]]</p>
<h1 id="rfc.section.8.4"><a href="#rfc.section.8.4">8.4.</a> <a href="#nonce-jws-header-parameter" id="nonce-jws-header-parameter">&#8220;nonce&#8221; JWS Header Parameter</a></h1>
<p id="rfc.section.8.4.p.1">The &#8220;JSON Web Signature and Encryption Header Parameters&#8221; registry should be updated with the following additional value:</p>
<p/>

<ul>
  <li>Header Parameter Name: &#8220;nonce&#8221;</li>
  <li>Header Parameter Description: Nonce</li>
  <li>Header Parameter Usage Location(s): JWE, JWS</li>
  <li>Change Controller: IESG</li>
  <li>Specification Document(s): <a href="#nonce-nonce-jws-header-parameter">Section 5.5.2</a> of RFC XXXX</li>
</ul>
<p id="rfc.section.8.4.p.3">[[ RFC EDITOR: Please replace XXXX above with the RFC number assigned to this document ]]</p>
<h1 id="rfc.section.8.5"><a href="#rfc.section.8.5">8.5.</a> <a href="#urn-sub-namespace-for-acme-urnietfparamsacme" id="urn-sub-namespace-for-acme-urnietfparamsacme">URN Sub-namespace for ACME (urn:ietf:params:acme)</a></h1>
<p id="rfc.section.8.5.p.1">The &#8220;IETF URN Sub-namespace for Registered Protocol Parameter Identifiers&#8221; registry should be updated with the following additional value, following the template in <a href="#RFC3553">[RFC3553]</a>:</p>
<p/>

<dl>
  <dt>Registry name:</dt>
  <dd style="margin-left: 8">acme</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">RFC XXXX</dd>
  <dt>Repository:</dt>
  <dd style="margin-left: 8">URL-TBD</dd>
  <dt>Index value:</dt>
  <dd style="margin-left: 8">No transformation needed.</dd>
</dl>
<p id="rfc.section.8.5.p.3">[[ RFC EDITOR: Please replace XXXX above with the RFC number assigned to this document, and replace URL-TBD with the URL assigned by IANA for registries of ACME parameters. ]]</p>
<h1 id="rfc.section.8.6"><a href="#rfc.section.8.6">8.6.</a> <a href="#new-registries" id="new-registries">New Registries</a></h1>
<p id="rfc.section.8.6.p.1">This document requests that IANA create the following new registries:</p>
<p/>

<ol>
  <li>ACME Account Object Fields (<a href="#iana-account">Section 8.6.1</a>)</li>
  <li>ACME Order Object Fields (<a href="#iana-order">Section 8.6.2</a>)</li>
  <li>ACME Error Types (<a href="#iana-error">Section 8.6.3</a>)</li>
  <li>ACME Resource Types (<a href="#iana-resource">Section 8.6.4</a>)</li>
  <li>ACME Identifier Types (<a href="#iana-identifier">Section 8.6.5</a>)</li>
  <li>ACME Challenge Types (<a href="#iana-challenge">Section 8.6.6</a>)</li>
</ol>
<p id="rfc.section.8.6.p.3">All of these registries are under a heading of &#8220;Automated Certificate Management Environment (ACME) Protocol&#8221; and are be administered under a Specification Required policy <a href="#RFC5226">[RFC5226]</a>.</p>
<h1 id="rfc.section.8.6.1"><a href="#rfc.section.8.6.1">8.6.1.</a> <a href="#iana-account" id="iana-account">Fields in Account Objects</a></h1>
<p id="rfc.section.8.6.1.p.1">This registry lists field names that are defined for use in ACME account objects.  Fields marked as &#8220;configurable&#8221; may be included in a new-account request.</p>
<p id="rfc.section.8.6.1.p.2">Template:</p>
<p/>

<ul>
  <li>Field name: The string to be used as a key in the JSON dictionary</li>
  <li>Field type: The type of value to be provided, e.g., string, boolean, array of string</li>
  <li>Client configurable: Boolean indicating whether the server should accept values provided by the client</li>
  <li>Reference: Where this field is defined</li>
</ul>
<p id="rfc.section.8.6.1.p.4">Initial contents: The fields and descriptions defined in <a href="#account-objects">Section 6.1.2</a>.</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="left">Field Name</th>
      <th class="left">Field Type</th>
      <th class="left">Configurable</th>
      <th class="left">Reference</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">key</td>
      <td class="left">dictionary</td>
      <td class="left">false</td>
      <td class="left">RFC XXXX</td>
    </tr>
    <tr>
      <td class="left">status</td>
      <td class="left">string</td>
      <td class="left">false</td>
      <td class="left">RFC XXXX</td>
    </tr>
    <tr>
      <td class="left">contact</td>
      <td class="left">array of string</td>
      <td class="left">true</td>
      <td class="left">RFC XXXX</td>
    </tr>
    <tr>
      <td class="left">external-account-binding</td>
      <td class="left">dictionary</td>
      <td class="left">true</td>
      <td class="left">RFC XXXX</td>
    </tr>
    <tr>
      <td class="left">terms-of-service-agreed</td>
      <td class="left">boolean</td>
      <td class="left">false</td>
      <td class="left">RFC XXXX</td>
    </tr>
    <tr>
      <td class="left">orders</td>
      <td class="left">array of string</td>
      <td class="left">false</td>
      <td class="left">RFC XXXX</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.section.8.6.2"><a href="#rfc.section.8.6.2">8.6.2.</a> <a href="#iana-order" id="iana-order">Fields in Order Objects</a></h1>
<p id="rfc.section.8.6.2.p.1">This registry lists field names that are defined for use in ACME order objects.  Fields marked as &#8220;configurable&#8221; may be included in a new-order request.</p>
<p id="rfc.section.8.6.2.p.2">Template:</p>
<p/>

<ul>
  <li>Field name: The string to be used as a key in the JSON dictionary</li>
  <li>Field type: The type of value to be provided, e.g., string, boolean, array of string</li>
  <li>Client configurable: Boolean indicating whether the server should accept values provided by the client</li>
  <li>Reference: Where this field is defined</li>
</ul>
<p id="rfc.section.8.6.2.p.4">Initial contents: The fields and descriptions defined in <a href="#order-objects">Section 6.1.3</a>.</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="left">Field Name</th>
      <th class="left">Field Type</th>
      <th class="left">Configurable</th>
      <th class="left">Reference</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">status</td>
      <td class="left">string</td>
      <td class="left">false</td>
      <td class="left">RFC XXXX</td>
    </tr>
    <tr>
      <td class="left">expires</td>
      <td class="left">string</td>
      <td class="left">false</td>
      <td class="left">RFC XXXX</td>
    </tr>
    <tr>
      <td class="left">csr</td>
      <td class="left">string</td>
      <td class="left">true</td>
      <td class="left">RFC XXXX</td>
    </tr>
    <tr>
      <td class="left">notBefore</td>
      <td class="left">string</td>
      <td class="left">true</td>
      <td class="left">RFC XXXX</td>
    </tr>
    <tr>
      <td class="left">notAfter</td>
      <td class="left">string</td>
      <td class="left">true</td>
      <td class="left">RFC XXXX</td>
    </tr>
    <tr>
      <td class="left">authorizations</td>
      <td class="left">array of string</td>
      <td class="left">false</td>
      <td class="left">RFC XXXX</td>
    </tr>
    <tr>
      <td class="left">certificate</td>
      <td class="left">string</td>
      <td class="left">false</td>
      <td class="left">RFC XXXX</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.section.8.6.3"><a href="#rfc.section.8.6.3">8.6.3.</a> <a href="#iana-error" id="iana-error">Error Types</a></h1>
<p id="rfc.section.8.6.3.p.1">This registry lists values that are used within URN values that are provided in the &#8220;type&#8221; field of problem documents in ACME.</p>
<p id="rfc.section.8.6.3.p.2">Template:</p>
<p/>

<ul>
  <li>Type: The label to be included in the URN for this error, following &#8220;urn:ietf:params:acme:&#8221;</li>
  <li>Description: A human-readable description of the error</li>
  <li>Reference: Where the error is defined</li>
</ul>
<p id="rfc.section.8.6.3.p.4">Initial contents: The types and descriptions in the table in <a href="#errors">Section 5.7</a> above, with the Reference field set to point to this specification.</p>
<h1 id="rfc.section.8.6.4"><a href="#rfc.section.8.6.4">8.6.4.</a> <a href="#iana-resource" id="iana-resource">Resource Types</a></h1>
<p id="rfc.section.8.6.4.p.1">This registry lists the types of resources that ACME servers may list in their directory objects.</p>
<p id="rfc.section.8.6.4.p.2">Template:</p>
<p/>

<ul>
  <li>Key: The value to be used as a dictionary key in the directory object</li>
  <li>Resource type: The type of resource labeled by the key</li>
  <li>Reference: Where the identifier type is defined</li>
</ul>
<p id="rfc.section.8.6.4.p.4">Initial contents:</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="left">Key</th>
      <th class="left">Resource type</th>
      <th class="left">Reference</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">new-account</td>
      <td class="left">New account</td>
      <td class="left">RFC XXXX</td>
    </tr>
    <tr>
      <td class="left">new-order</td>
      <td class="left">New order</td>
      <td class="left">RFC XXXX</td>
    </tr>
    <tr>
      <td class="left">revoke-cert</td>
      <td class="left">Revoke certificate</td>
      <td class="left">RFC XXXX</td>
    </tr>
    <tr>
      <td class="left">key-change</td>
      <td class="left">Key change</td>
      <td class="left">RFC XXXX</td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.8.6.4.p.5">[[ RFC EDITOR: Please replace XXXX above with the RFC number assigned to this document ]]</p>
<h1 id="rfc.section.8.6.5"><a href="#rfc.section.8.6.5">8.6.5.</a> <a href="#iana-identifier" id="iana-identifier">Identifier Types</a></h1>
<p id="rfc.section.8.6.5.p.1">This registry lists the types of identifiers that ACME clients may request authorization to issue in certificates.</p>
<p id="rfc.section.8.6.5.p.2">Template:</p>
<p/>

<ul>
  <li>Label: The value to be put in the &#8220;type&#8221; field of the identifier object</li>
  <li>Reference: Where the identifier type is defined</li>
</ul>
<p id="rfc.section.8.6.5.p.4">Initial contents:</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="left">Label</th>
      <th class="left">Reference</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">dns</td>
      <td class="left">RFC XXXX</td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.8.6.5.p.5">[[ RFC EDITOR: Please replace XXXX above with the RFC number assigned to this document ]]</p>
<h1 id="rfc.section.8.6.6"><a href="#rfc.section.8.6.6">8.6.6.</a> <a href="#iana-challenge" id="iana-challenge">Challenge Types</a></h1>
<p id="rfc.section.8.6.6.p.1">This registry lists the ways that ACME servers can offer to validate control of an identifier.  The &#8220;Identifier Type&#8221; field in template must be contained in the Label column of the ACME Identifier Types registry.</p>
<p id="rfc.section.8.6.6.p.2">Template:</p>
<p/>

<ul>
  <li>Label: The value to be put in the &#8220;type&#8221; field of challenge objects using this validation mechanism</li>
  <li>Identifier Type: The type of identifier that this mechanism applies to</li>
  <li>Reference: Where the challenge type is defined</li>
</ul>
<p id="rfc.section.8.6.6.p.4">Initial Contents</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="left">Label</th>
      <th class="left">Identifier Type</th>
      <th class="left">Reference</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">http</td>
      <td class="left">dns</td>
      <td class="left">RFC XXXX</td>
    </tr>
    <tr>
      <td class="left">tls-sni</td>
      <td class="left">dns</td>
      <td class="left">RFC XXXX</td>
    </tr>
    <tr>
      <td class="left">dns</td>
      <td class="left">dns</td>
      <td class="left">RFC XXXX</td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.8.6.6.p.5">[[ RFC EDITOR: Please replace XXXX above with the RFC number assigned to this document ]]</p>
<h1 id="rfc.section.9"><a href="#rfc.section.9">9.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a></h1>
<p id="rfc.section.9.p.1">ACME is a protocol for managing certificates that attest to identifier/key bindings.  Thus the foremost security goal of ACME is to ensure the integrity of this process, i.e., to ensure that the bindings attested by certificates are correct, and that only authorized entities can manage certificates.  ACME identifies clients by their account keys, so this overall goal breaks down into two more precise goals:</p>
<p/>

<ol>
  <li>Only an entity that controls an identifier can get an account key authorized for that identifier</li>
  <li>Once authorized, an account key&#8217;s authorizations cannot be improperly transferred to another account key</li>
</ol>
<p id="rfc.section.9.p.3">In this section, we discuss the threat model that underlies ACME and the ways that ACME achieves these security goals within that threat model.  We also discuss the denial-of-service risks that ACME servers face, and a few other miscellaneous considerations.</p>
<h1 id="rfc.section.9.1"><a href="#rfc.section.9.1">9.1.</a> <a href="#threat-model" id="threat-model">Threat model</a></h1>
<p id="rfc.section.9.1.p.1">As a service on the Internet, ACME broadly exists within the Internet threat model <a href="#RFC3552">[RFC3552]</a>.  In analyzing ACME, it is useful to think of an ACME server interacting with other Internet hosts along two &#8220;channels&#8221;:</p>
<p/>

<ul>
  <li>An ACME channel, over which the ACME HTTPS requests are exchanged</li>
  <li>A validation channel, over which the ACME server performs additional requests to validate a client&#8217;s control of an identifier</li>
</ul>
<pre>
+------------+
|    ACME    |     ACME Channel
|   Client   |--------------------+
+------------+                    |
                                  V
                            +------------+
                            |    ACME    |
                            |   Server   |
                            +------------+
+------------+                    |
| Validation |&lt;-------------------+
|   Server   |  Validation Channel
+------------+
</pre>
<p id="rfc.section.9.1.p.3">In practice, the risks to these channels are not entirely separate, but they are different in most cases.  Each channel, for example, uses a different communications pattern: the ACME channel will comprise inbound HTTPS connections to the ACME server and the validation channel outbound HTTP or DNS requests.</p>
<p id="rfc.section.9.1.p.4">Broadly speaking, ACME aims to be secure against active and passive attackers on any individual channel.  Some vulnerabilities arise (noted below), when an attacker can exploit both the ACME channel and one of the others.</p>
<p id="rfc.section.9.1.p.5">On the ACME channel, in addition to network-layer attackers, we also need to account for application-layer man-in-the-middle (MitM) attacks, and for abusive use of the protocol itself.  Protection against application-layer MitM addresses potential attackers such as Content Distribution Networks (CDNs) and middleboxes with a TLS MitM function.  Preventing abusive use of ACME means ensuring that an attacker with access to the validation channel can&#8217;t obtain illegitimate authorization by acting as an ACME client (legitimately, in terms of the protocol).</p>
<h1 id="rfc.section.9.2"><a href="#rfc.section.9.2">9.2.</a> <a href="#integrity-of-authorizations" id="integrity-of-authorizations">Integrity of Authorizations</a></h1>
<p id="rfc.section.9.2.p.1">ACME allows anyone to request challenges for an identifier by registering an account key and sending a new-order request under that account key.  The integrity of the authorization process thus depends on the identifier validation challenges to ensure that the challenge can only be completed by someone who both (1) holds the private key of the account key pair, and (2) controls the identifier in question.</p>
<p id="rfc.section.9.2.p.2">Validation responses need to be bound to an account key pair in order to avoid situations where an ACME MitM can switch out a legitimate domain holder&#8217;s account key for one of his choosing, e.g.:</p>
<p/>

<ul>
  <li>Legitimate domain holder registers account key pair A</li>
  <li>MitM registers account key pair B</li>
  <li>Legitimate domain holder sends a new-order request signed under account key A</li>
  <li>MitM suppresses the legitimate request, but sends the same request signed under account key B</li>
  <li>ACME server issues challenges and MitM forwards them to the legitimate domain holder</li>
  <li>Legitimate domain holder provisions the validation response</li>
  <li>ACME server performs validation query and sees the response provisioned by the legitimate domain holder</li>
  <li>Because the challenges were issued in response to a message signed account key B, the ACME server grants authorization to account key B (the MitM) instead of account key A (the legitimate domain holder)</li>
</ul>
<p id="rfc.section.9.2.p.4">All of the challenges above have a binding between the account private key and the validation query made by the server, via the key authorization.  The key authorization is signed by the account private key, reflects the corresponding public key, and is provided to the server in the validation response.</p>
<p id="rfc.section.9.2.p.5">The association of challenges to identifiers is typically done by requiring the client to perform some action that only someone who effectively controls the identifier can perform.  For the challenges in this document, the actions are:</p>
<p/>

<ul>
  <li>HTTP: Provision files under .well-known on a web server for the domain</li>
  <li>TLS SNI: Configure a TLS server for the domain</li>
  <li>DNS: Provision DNS resource records for the domain</li>
</ul>
<p id="rfc.section.9.2.p.7">There are several ways that these assumptions can be violated, both by misconfiguration and by attack.  For example, on a web server that allows non-administrative users to write to .well-known, any user can claim to own the server&#8217;s hostname by responding to an HTTP challenge, and likewise for TLS configuration and TLS SNI.</p>
<p id="rfc.section.9.2.p.8">The use of hosting providers is a particular risk for ACME validation.  If the owner of the domain has outsourced operation of DNS or web services to a hosting provider, there is nothing that can be done against tampering by the hosting provider.  As far as the outside world is concerned, the zone or web site provided by the hosting provider is the real thing.</p>
<p id="rfc.section.9.2.p.9">More limited forms of delegation can also lead to an unintended party gaining the ability to successfully complete a validation transaction.  For example, suppose an ACME server follows HTTP redirects in HTTP validation and a web site operator provisions a catch-all redirect rule that redirects requests for unknown resources to a different domain.  Then the target of the redirect could use that to get a certificate through HTTP validation, since the validation path will not be known to the primary server.</p>
<p id="rfc.section.9.2.p.10">The DNS is a common point of vulnerability for all of these challenges.  An entity that can provision false DNS records for a domain can attack the DNS challenge directly, and can provision false A/AAAA records to direct the ACME server to send its TLS SNI or HTTP validation query to a server of the attacker&#8217;s choosing.  There are a few different mitigations that ACME servers can apply:</p>
<p/>

<ul>
  <li>Always querying the DNS using a DNSSEC-validating resolver (enhancing security for zones that are DNSSEC-enabled)</li>
  <li>Querying the DNS from multiple vantage points to address local attackers</li>
  <li>Applying mitigations against DNS off-path attackers, e.g., adding entropy to requests <a href="#I-D.vixie-dnsext-dns0x20">[I-D.vixie-dnsext-dns0x20]</a> or only using TCP</li>
</ul>
<p id="rfc.section.9.2.p.12">Given these considerations, the ACME validation process makes it impossible for any attacker on the ACME channel, or a passive attacker on the validation channel to hijack the authorization process to authorize a key of the attacker&#8217;s choice.</p>
<p id="rfc.section.9.2.p.13">An attacker that can only see the ACME channel would need to convince the validation server to provide a response that would authorize the attacker&#8217;s account key, but this is prevented by binding the validation response to the account key used to request challenges.  A passive attacker on the validation channel can observe the correct validation response and even replay it, but that response can only be used with the account key for which it was generated.</p>
<p id="rfc.section.9.2.p.14">An active attacker on the validation channel can subvert the ACME process, by performing normal ACME transactions and providing a validation response for his own account key.  The risks due to hosting providers noted above are a particular case.  For identifiers where the server already has some public key associated with the domain this attack can be prevented by requiring the client to prove control of the corresponding private key.</p>
<h1 id="rfc.section.9.3"><a href="#rfc.section.9.3">9.3.</a> <a href="#denial-of-service-considerations" id="denial-of-service-considerations">Denial-of-Service Considerations</a></h1>
<p id="rfc.section.9.3.p.1">As a protocol run over HTTPS, standard considerations for TCP-based and HTTP-based DoS mitigation also apply to ACME.</p>
<p id="rfc.section.9.3.p.2">At the application layer, ACME requires the server to perform a few potentially expensive operations.  Identifier validation transactions require the ACME server to make outbound connections to potentially attacker-controlled servers, and certificate issuance can require interactions with cryptographic hardware.</p>
<p id="rfc.section.9.3.p.3">In addition, an attacker can also cause the ACME server to send validation requests to a domain of its choosing by submitting authorization requests for the victim domain.</p>
<p id="rfc.section.9.3.p.4">All of these attacks can be mitigated by the application of appropriate rate limits.  Issues closer to the front end, like POST body validation, can be addressed using HTTP request limiting.  For validation and certificate requests, there are other identifiers on which rate limits can be keyed.  For example, the server might limit the rate at which any individual account key can issue certificates, or the rate at which validation can be requested within a given subtree of the DNS.</p>
<h1 id="rfc.section.9.4"><a href="#rfc.section.9.4">9.4.</a> <a href="#server-side-request-forgery" id="server-side-request-forgery">Server-Side Request Forgery</a></h1>
<p id="rfc.section.9.4.p.1">Server-Side Request Forgery (SSRF) attacks can arise when an attacker can cause a server to perform HTTP requests to an attacker-chosen URL.  In the ACME HTTP challenge validation process, the ACME server performs an HTTP GET request to a URL in which the attacker can choose the domain.  This request is made before the server has verified that the client controls the domain, so any client can cause a query to any domain.</p>
<p id="rfc.section.9.4.p.2">Some server implementations include information from the validation server&#8217;s response (in order to facilitate debugging).  Such implementations enable an attacker to extract this information from any web server that is accessible to the ACME server, even if it is not accessible to the ACME client.</p>
<p id="rfc.section.9.4.p.3">It might seem that the risk of SSRF through this channel is limited by the fact that the attacker can only control the domain of the URL, not the path.  However, if the attacker first sets the domain to one they control, then they can send the server an HTTP redirect (e.g., a 302 response) which will cause the server to query an arbitrary URI.</p>
<p id="rfc.section.9.4.p.4">In order to further limit the SSRF risk, ACME server operators should ensure that validation queries can only be sent to servers on the public Internet, and not, say, web services within the server operator&#8217;s internal network.  Since the attacker could make requests to these public servers himself, he can&#8217;t gain anything extra through an SSRF attack on ACME aside from a layer of anonymization.</p>
<h1 id="rfc.section.9.5"><a href="#rfc.section.9.5">9.5.</a> <a href="#ca-policy-considerations" id="ca-policy-considerations">CA Policy Considerations</a></h1>
<p id="rfc.section.9.5.p.1">The controls on issuance enabled by ACME are focused on validating that a certificate applicant controls the identifier he claims.  Before issuing a certificate, however, there are many other checks that a CA might need to perform, for example:</p>
<p/>

<ul>
  <li>Has the client agreed to a subscriber agreement?</li>
  <li>Is the claimed identifier syntactically valid?</li>
  <li>For domain names: <ul><li>If the leftmost label is a &#8216;*&#8217;, then have the appropriate checks been applied?</li><li>Is the name on the Public Suffix List?</li><li>Is the name a high-value name?</li><li>Is the name a known phishing domain?</li></ul></li>
  <li>Is the key in the CSR sufficiently strong?</li>
  <li>Is the CSR signed with an acceptable algorithm?</li>
</ul>
<p id="rfc.section.9.5.p.3">CAs that use ACME to automate issuance will need to ensure that their servers perform all necessary checks before issuing.</p>
<p id="rfc.section.9.5.p.4">CAs using ACME to allow clients to agree to terms of service should keep in mind that ACME clients can automate this agreement, possibly not involving a human user.  If a CA wishes to have stronger evidence of user consent, it may present an out-of-band requirement or challenge to require human involvement.</p>
<h1 id="rfc.section.10"><a href="#rfc.section.10">10.</a> <a href="#operational-considerations" id="operational-considerations">Operational Considerations</a></h1>
<p id="rfc.section.10.p.1">There are certain factors that arise in operational reality that operators of ACME-based CAs will need to keep in mind when configuring their services.  For example:</p>
<h1 id="rfc.section.10.1"><a href="#rfc.section.10.1">10.1.</a> <a href="#dns-security" id="dns-security">DNS security</a></h1>
<p id="rfc.section.10.1.p.1">As noted above, DNS forgery attacks against the ACME server can result in the server making incorrect decisions about domain control and thus mis-issuing certificates. Servers SHOULD perform DNS queries over TCP, which provides better resistance to some forgery attacks than DNS over UDP.</p>
<p id="rfc.section.10.1.p.2">An ACME-based CA will often need to make DNS queries, e.g., to validate control of DNS names.  Because the security of such validations ultimately depends on the authenticity of DNS data, every possible precaution should be taken to secure DNS queries done by the CA. It is therefore RECOMMENDED that ACME-based CAs make all DNS queries via DNSSEC-validating stub or recursive resolvers. This provides additional protection to domains which choose to make use of DNSSEC.</p>
<p id="rfc.section.10.1.p.3">An ACME-based CA must use only a resolver if it trusts the resolver and every component of the network route by which it is accessed. It is therefore RECOMMENDED that ACME-based CAs operate their own DNSSEC-validating resolvers within their trusted network and use these resolvers both for both CAA record lookups and all record lookups in furtherance of a challenge scheme (A, AAAA, TXT, etc.).</p>
<h1 id="rfc.section.10.2"><a href="#rfc.section.10.2">10.2.</a> <a href="#default-virtual-hosts" id="default-virtual-hosts">Default Virtual Hosts</a></h1>
<p id="rfc.section.10.2.p.1">In many cases, TLS-based services are deployed on hosted platforms that use the Server Name Indication (SNI) TLS extension to distinguish between different hosted services or &#8220;virtual hosts&#8221;.  When a client initiates a TLS connection with an SNI value indicating a provisioned host, the hosting platform routes the connection to that host.</p>
<p id="rfc.section.10.2.p.2">When a connection comes in with an unknown SNI value, one might expect the hosting platform to terminate the TLS connection.  However, some hosting platforms will choose a virtual host to be the &#8220;default&#8221;, and route connections with unknown SNI values to that host.</p>
<p id="rfc.section.10.2.p.3">In such cases, the owner of the default virtual host can complete a TLS-based challenge (e.g., &#8220;tls-sni-02&#8221;) for any domain with an A record that points to the hosting platform.  This could result in mis-issuance in cases where there are multiple hosts with different owners resident on the hosting platform.</p>
<p id="rfc.section.10.2.p.4">A CA that accepts TLS-based proof of domain control should attempt to check whether a domain is hosted on a domain with a default virtual host before allowing an authorization request for this host to use a TLS-based challenge.  A default virtual host can be detected by initiating TLS connections to the host with random SNI values within the namespace used for the TLS-based challenge (the &#8220;acme.invalid&#8221; namespace for &#8220;tls-sni-02&#8221;).</p>
<h1 id="rfc.section.11"><a href="#rfc.section.11">11.</a> <a href="#acknowledgements" id="acknowledgements">Acknowledgements</a></h1>
<p id="rfc.section.11.p.1">In addition to the editors listed on the front page, this document has benefited from contributions from a broad set of contributors, all the way back to its inception.</p>
<p/>

<ul>
  <li>Peter Eckersley, EFF</li>
  <li>Eric Rescorla, Mozilla</li>
  <li>Seth Schoen, EFF</li>
  <li>Alex Halderman, University of Michigan</li>
  <li>Martin Thomson, Mozilla</li>
  <li>Jakub Warmuz, University of Oxford</li>
</ul>
<p id="rfc.section.11.p.3">This document draws on many concepts established by Eric Rescorla&#8217;s &#8220;Automated Certificate Issuance Protocol&#8221; draft.  Martin Thomson provided helpful guidance in the use of HTTP.</p>
<h1 id="rfc.references"><a href="#rfc.references">12.</a> References</h1>
<h1 id="rfc.references.1"><a href="#rfc.references.1">12.1.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="FIPS180-4">[FIPS180-4]</b>
      </td>
      <td class="top"><a>Department of Commerce, National.</a>, "<a href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">NIST FIPS 180-4, Secure Hash Standard</a>", March 2012.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2585">[RFC2585]</b>
      </td>
      <td class="top"><a>Housley, R.</a> and <a>P. Hoffman</a>, "<a href="http://tools.ietf.org/html/rfc2585">Internet X.509 Public Key Infrastructure Operational Protocols: FTP and HTTP</a>", RFC 2585, DOI 10.17487/RFC2585, May 1999.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2818">[RFC2818]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/rfc2818">HTTP Over TLS</a>", RFC 2818, DOI 10.17487/RFC2818, May 2000.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2985">[RFC2985]</b>
      </td>
      <td class="top"><a>Nystrom, M.</a> and <a>B. Kaliski</a>, "<a href="http://tools.ietf.org/html/rfc2985">PKCS #9: Selected Object Classes and Attribute Types Version 2.0</a>", RFC 2985, DOI 10.17487/RFC2985, November 2000.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2986">[RFC2986]</b>
      </td>
      <td class="top"><a>Nystrom, M.</a> and <a>B. Kaliski</a>, "<a href="http://tools.ietf.org/html/rfc2986">PKCS #10: Certification Request Syntax Specification Version 1.7</a>", RFC 2986, DOI 10.17487/RFC2986, November 2000.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3339">[RFC3339]</b>
      </td>
      <td class="top"><a>Klyne, G.</a> and <a>C. Newman</a>, "<a href="http://tools.ietf.org/html/rfc3339">Date and Time on the Internet: Timestamps</a>", RFC 3339, DOI 10.17487/RFC3339, July 2002.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3492">[RFC3492]</b>
      </td>
      <td class="top"><a>Costello, A.</a>, "<a href="http://tools.ietf.org/html/rfc3492">Punycode: A Bootstring encoding of Unicode for Internationalized Domain Names in Applications (IDNA)</a>", RFC 3492, DOI 10.17487/RFC3492, March 2003.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3986">[RFC3986]</b>
      </td>
      <td class="top"><a>Berners-Lee, T.</a>, <a>Fielding, R.</a> and <a>L. Masinter</a>, "<a href="http://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4648">[RFC4648]</b>
      </td>
      <td class="top"><a>Josefsson, S.</a>, "<a href="http://tools.ietf.org/html/rfc4648">The Base16, Base32, and Base64 Data Encodings</a>", RFC 4648, DOI 10.17487/RFC4648, October 2006.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5226">[RFC5226]</b>
      </td>
      <td class="top"><a>Narten, T.</a> and <a>H. Alvestrand</a>, "<a href="http://tools.ietf.org/html/rfc5226">Guidelines for Writing an IANA Considerations Section in RFCs</a>", BCP 26, RFC 5226, DOI 10.17487/RFC5226, May 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5246">[RFC5246]</b>
      </td>
      <td class="top"><a>Dierks, T.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>", RFC 5246, DOI 10.17487/RFC5246, August 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5280">[RFC5280]</b>
      </td>
      <td class="top"><a>Cooper, D.</a>, <a>Santesson, S.</a>, <a>Farrell, S.</a>, <a>Boeyen, S.</a>, <a>Housley, R.</a> and <a>W. Polk</a>, "<a href="http://tools.ietf.org/html/rfc5280">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>", RFC 5280, DOI 10.17487/RFC5280, May 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5890">[RFC5890]</b>
      </td>
      <td class="top"><a>Klensin, J.</a>, "<a href="http://tools.ietf.org/html/rfc5890">Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework</a>", RFC 5890, DOI 10.17487/RFC5890, August 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5988">[RFC5988]</b>
      </td>
      <td class="top"><a>Nottingham, M.</a>, "<a href="http://tools.ietf.org/html/rfc5988">Web Linking</a>", RFC 5988, DOI 10.17487/RFC5988, October 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6066">[RFC6066]</b>
      </td>
      <td class="top"><a>Eastlake 3rd, D.</a>, "<a href="http://tools.ietf.org/html/rfc6066">Transport Layer Security (TLS) Extensions: Extension Definitions</a>", RFC 6066, DOI 10.17487/RFC6066, January 2011.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6570">[RFC6570]</b>
      </td>
      <td class="top"><a>Gregorio, J.</a>, <a>Fielding, R.</a>, <a>Hadley, M.</a>, <a>Nottingham, M.</a> and <a>D. Orchard</a>, "<a href="http://tools.ietf.org/html/rfc6570">URI Template</a>", RFC 6570, DOI 10.17487/RFC6570, March 2012.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6844">[RFC6844]</b>
      </td>
      <td class="top"><a>Hallam-Baker, P.</a> and <a>R. Stradling</a>, "<a href="http://tools.ietf.org/html/rfc6844">DNS Certification Authority Authorization (CAA) Resource Record</a>", RFC 6844, DOI 10.17487/RFC6844, January 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7159">[RFC7159]</b>
      </td>
      <td class="top"><a>Bray, T.</a>, "<a href="http://tools.ietf.org/html/rfc7159">The JavaScript Object Notation (JSON) Data Interchange Format</a>", RFC 7159, DOI 10.17487/RFC7159, March 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7231">[RFC7231]</b>
      </td>
      <td class="top"><a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="http://tools.ietf.org/html/rfc7231">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>", RFC 7231, DOI 10.17487/RFC7231, June 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7468">[RFC7468]</b>
      </td>
      <td class="top"><a>Josefsson, S.</a> and <a>S. Leonard</a>, "<a href="http://tools.ietf.org/html/rfc7468">Textual Encodings of PKIX, PKCS, and CMS Structures</a>", RFC 7468, DOI 10.17487/RFC7468, April 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7515">[RFC7515]</b>
      </td>
      <td class="top"><a>Jones, M.</a>, <a>Bradley, J.</a> and <a>N. Sakimura</a>, "<a href="http://tools.ietf.org/html/rfc7515">JSON Web Signature (JWS)</a>", RFC 7515, DOI 10.17487/RFC7515, May 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7517">[RFC7517]</b>
      </td>
      <td class="top"><a>Jones, M.</a>, "<a href="http://tools.ietf.org/html/rfc7517">JSON Web Key (JWK)</a>", RFC 7517, DOI 10.17487/RFC7517, May 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7518">[RFC7518]</b>
      </td>
      <td class="top"><a>Jones, M.</a>, "<a href="http://tools.ietf.org/html/rfc7518">JSON Web Algorithms (JWA)</a>", RFC 7518, DOI 10.17487/RFC7518, May 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7638">[RFC7638]</b>
      </td>
      <td class="top"><a>Jones, M.</a> and <a>N. Sakimura</a>, "<a href="http://tools.ietf.org/html/rfc7638">JSON Web Key (JWK) Thumbprint</a>", RFC 7638, DOI 10.17487/RFC7638, September 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7807">[RFC7807]</b>
      </td>
      <td class="top"><a>Nottingham, M.</a> and <a>E. Wilde</a>, "<a href="http://tools.ietf.org/html/rfc7807">Problem Details for HTTP APIs</a>", RFC 7807, DOI 10.17487/RFC7807, March 2016.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.references.2"><a href="#rfc.references.2">12.2.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.vixie-dnsext-dns0x20">[I-D.vixie-dnsext-dns0x20]</b>
      </td>
      <td class="top"><a>Vixie, P.</a> and <a>D. Dagon</a>, "<a href="http://tools.ietf.org/html/draft-vixie-dnsext-dns0x20-00">Use of Bit 0x20 in DNS Labels to Improve Transaction Identity</a>", Internet-Draft draft-vixie-dnsext-dns0x20-00, March 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3552">[RFC3552]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a> and <a>B. Korver</a>, "<a href="http://tools.ietf.org/html/rfc3552">Guidelines for Writing RFC Text on Security Considerations</a>", BCP 72, RFC 3552, DOI 10.17487/RFC3552, July 2003.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3553">[RFC3553]</b>
      </td>
      <td class="top"><a>Mealling, M.</a>, <a>Masinter, L.</a>, <a>Hardie, T.</a> and <a>G. Klyne</a>, "<a href="http://tools.ietf.org/html/rfc3553">An IETF URN Sub-namespace for Registered Protocol Parameters</a>", BCP 73, RFC 3553, DOI 10.17487/RFC3553, June 2003.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5785">[RFC5785]</b>
      </td>
      <td class="top"><a>Nottingham, M.</a> and <a>E. Hammer-Lahav</a>, "<a href="http://tools.ietf.org/html/rfc5785">Defining Well-Known Uniform Resource Identifiers (URIs)</a>", RFC 5785, DOI 10.17487/RFC5785, April 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6962">[RFC6962]</b>
      </td>
      <td class="top"><a>Laurie, B.</a>, <a>Langley, A.</a> and <a>E. Kasper</a>, "<a href="http://tools.ietf.org/html/rfc6962">Certificate Transparency</a>", RFC 6962, DOI 10.17487/RFC6962, June 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7469">[RFC7469]</b>
      </td>
      <td class="top"><a>Evans, C.</a>, <a>Palmer, C.</a> and <a>R. Sleevi</a>, "<a href="http://tools.ietf.org/html/rfc7469">Public Key Pinning Extension for HTTP</a>", RFC 7469, DOI 10.17487/RFC7469, April 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="W3C.CR-cors-20130129">[W3C.CR-cors-20130129]</b>
      </td>
      <td class="top"><a>Kesteren, A.</a>, "<a href="http://www.w3.org/TR/2013/CR-cors-20130129">Cross-Origin Resource Sharing</a>", World Wide Web Consortium CR CR-cors-20130129, January 2013.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Richard Barnes</span> 
	  <span class="n hidden">
		<span class="family-name">Barnes</span>
	  </span>
	</span>
	<span class="org vcardline">Mozilla</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:rlb@ipv.sx">rlb@ipv.sx</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Jacob Hoffman-Andrews</span> 
	  <span class="n hidden">
		<span class="family-name">Hoffman-Andrews</span>
	  </span>
	</span>
	<span class="org vcardline">EFF</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:jsha@eff.org">jsha@eff.org</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">James Kasten</span> 
	  <span class="n hidden">
		<span class="family-name">Kasten</span>
	  </span>
	</span>
	<span class="org vcardline">University of Michigan</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:jdkasten@umich.edu">jdkasten@umich.edu</a></span>

  </address>
</div>

  <div class="github-fork-ribbon-wrapper"><div class="github-fork-ribbon"><a href="https://github.com/ietf-wg-acme/acme">Fork me on GitHub</a></div></div>
</body>
</html>
